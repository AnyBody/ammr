///************ Shoulder Rhythm **********************
/// The ShoulderRhythm  creates two constraints that will drive ClaviculaElevation and ClaviculaProtraction based on rotations measured btw thorax and humerus
/// Based on the concepts from
/// De Groot, J. H. The shoulder: a kinematic and dynamic analysis of motion and loading. (1998)
/// The data for the rhythm does not apply for negative elevation planes so the contribution for negative plane are zeroed
AnyKinEq ShoulderRhythm ={
 
   ///Measure for clavicula protraction as a function of thorax humerus elevation and elevation plane 
   AnyKinMeasureLinComb ClaviculaProtractionRhythm =  {
      AnyKinMeasure& ClaviculaProtraction = ...InterfaceFolder.SternoClavicularProtraction;
      AnyKinMeasure& HumerusElevation =   .Measures.Elevation;
      AnyKinMeasure& HumerusElevationPlane = .Measures.ElevationPlane;
      OutDim = 1;
      // These coefficients are tweaked compared to De Groot et al (1998) to achive a behaviour
      // where the shoulder also works when the arm is lifted in negative elevation planes (not part
      // of the paper), as well as a neutral shoulder position similar to models without the shoulder rhythm.
      //    Coef = {{1, 0.242, -0.12}};
      //    Const = -1*{(-4.983*pi/180)};
      Coef = {{1, 0.14, -0.15}};
      Const = -1*{(-23*pi/180)};
   };
  
    ///Measure for clavicula protraction as a function of thorax humerus elevation and elevation plane
    AnyKinMeasureLinComb ClaviculaElevationRhythm =  {
      AnyKinMeasure& ClaviculaElevation = ...InterfaceFolder.SternoClavicularElevation;
      AnyKinMeasure& HumerusElevation =   .Measures.Elevation;
      AnyKinMeasure& HumerusElevationPlane = .Measures.ElevationPlane;
      OutDim = 1;
      Coef = {{1, -0.123, 0.046}};
      Const = -1*{(3.917*pi/180)};
    };

    // Use a template to create the weight function, so
    // the weight values can be overridden by the user.
    Template_AnyFunConst Weights (NUMBER_OF_ELEMENTS=..nDim) = {};
    WeightFun ={&Weights.Fun};
    
    #if BM_ARM_SHOULDER_RHYTHM == _RHYTHM_SOFT_
    CType= repmat(nDim,Soft);
    #endif

    Reaction.Type = repmat(nDim,Off);

    ///Additional measures needed these are not driven directly
    AnyFolder Measures ={
     
     //This "gear" should not be needed... but it makes handling of zero position which is singular by nature in the ThoraxHumerus measure handle better numerically   
     AnyFunInterpol Gear_Elevation ={
      T ??= farr(-400.0,0.5,1600)*pi/180;
      Data ??= {abs(T)};
      Type = Bspline;
    };
    
    AnyKinMeasureFunComb1 Elevation =   {
      AnyKinMeasure& SternoClavicularElevation = ....InterfaceFolder.ThoraxHumerus_Positive_Elevation.Elevation;
      Functions = {&.Gear_Elevation};
    };
    
    ///Data in article does not cover negative elevation planes
    ///This gear will make a negative elevation plane zero so that the effect of having a negative elevation plane will be zero.
    AnyFunInterpol Gear_ElevationPlane ={
      T ??= farr(-400.0,0.5,1600)*pi/180;
      Data ??=  {iffun(gteqfun(T,0),T,0.0)};
      Type = Bspline;
    };
    
    AnyKinMeasureFunComb1 ElevationPlane =   {
      AnyKinMeasure& HumerusElevationPlane = ....InterfaceFolder.ThoraxHumerus_Positive_Elevation.PlaneOfElevation;
      Functions = {&.Gear_Elevation};
    };
  };
};
  


#if BM_ARM_CLAVICULA_ROTATION_RHYTHM == OFF
AnyKinEq ClaviculaAxialRotationRhythm =
{
  AnyKinMeasureLinComb ClaviculaAxialRotationRhythm =
  {
    AnyKinMeasure& ClaviculaAxialRotation = ...InterfaceFolder.SternoClavicularAxialRotation;
    AnyKinMeasure& HumerusElevation = ..InterfaceFolder.GlenohumeralAbduction;
    OutDim = 1;
    Coef = {{1, -0.422}};
    Const = -1*{-0.423};   // initial position -0.349 rad, constant found by iteration (data non available)
  };
  
  // Use a template to create the weight function, so
  // the weight values can be overridden by the user.
  Template_AnyFunConst Weights (NUMBER_OF_ELEMENTS=..nDim) = {};
  WeightFun ={&Weights.Fun};
  #if BM_ARM_SHOULDER_RHYTHM == _RHYTHM_SOFT_
  CType= repmat(nDim,Soft);
  #endif
  
  Reaction.Type = repmat(nDim,Off);
};
#endif

