



// This file contains segment inertia properties and geometry used for muscle wrapping.
// The file includes a number of segment files which contains muscles attachment points and 
// bonylandmarks.
MultiWrapSurfs CylindersPosterior (
     BASE_FRAME = .DeltoidPosteriorWrapping.Cyl.gh.DeltoidPosteriorWrap,

     TYPE="ELIPSOID",
     NUMBER_OF_CYLINDERS= 4,
     DEBUG=0
     ) = 
   {     
       Radius = .Humerus.test_fitting_2.scaledposterior.Radius[1];
       RadiusX = .Humerus.test_fitting_2.scaledposterior.Radius[0];
       RadiusHeight = .Humerus.test_fitting_2.scaledposterior.Radius[2];


       WrapSurfLength = 0.8;
       //Angles = ({15, 17, 20, 30}-10);

       Angles = ..Sign*({15, 17, 20, 30}-10);
       //Angles = {0,0,0,0};
       Visibility = repmat(NumberOfCylinders, On);
//         Visibility = {On, Off, Off, Off};
   }; 



AnyFolder DeltoidPosteriorWrapping ={
  
  AnySeg Cyl ={
    
    r0=...Seg.Scapula.r0;
    Axes0=...Seg.Scapula.Axes0;
    Mass=0;
    Jii={0,0,0};
    AnyRefNode ai= {sRel=....Seg.Scapula.ai.sRel;};
    AnyRefNode gh= {
      sRel=....Seg.Scapula.gh.sRel;
      ARel=....Seg.Scapula.gh.ARel;
      AnyRefNode DeltoidPosteriorWrap ={
      //  AnyDrawRefFrame drw2 ={ScaleXYZ={1,1,1};};
        
        sRel=.....Seg.Scapula.gh.DeltoidPosteriorWrap.sRel;
        ARel=.....Seg.Scapula.gh.DeltoidPosteriorWrap.ARel*RotMat((1-.....Sign)*0.5*pi,y);
//        ARel=.....Seg.Scapula.gh.DeltoidPosteriorWrap.ARel;


      };
      
    };
    AnyRefNode RotNode= {
      sRel=.gh.sRel;
      ARel =RotMat(sRel,.ai.sRel,....Seg.Scapula.ts.sRel);
//      AnyDrawRefFrame drw ={
//        ScaleXYZ={1,1,1}*0.3;
//        RGB={0,1,0};};
    };
  };
  
  
  
  
  AnySphericalJoint ai_Joint={
    AnyRefNode &ref1=.Cyl.ai;
    AnyRefNode &ref2=...Seg.Scapula.ai;
  };
  
  AnyKinLinear gh_lin ={
    AnyRefNode &ref1=.Cyl.gh;
    AnyRefNode &ref2=...Seg.Humerus.gh;
    Ref=0;
  };
  
  AnyKinEq gh_lin_drv ={
    AnyKinLinear &ref=.gh_lin;
    MeasureOrganizer ={1,2};  //x is long axis...not to be driven 
  };
  
  AnyKinRotational ai_rot ={
    AnyRefNode &ref1=.Cyl.ai;
    AnyRefNode &ref2=...Seg.Scapula.ai;
    Type=RotAxesAngles;

    Axis1=x;
        Axis2=y;
            Axis3=z;
  };
  
  AnyKinEq ai_rot_drv ={
    AnyKinRotational &ref=.ai_rot;
    MeasureOrganizer ={0};  //x is long axis...rot around it to be driven 
  };

  
};





//DeltoidLateralAndAnteriorWrapping
AnyFolder DeltoidLateralAndAnteriorWrapping ={
  
  
  MultiWrapSurfs Cylinders (
  BASE_FRAME = .DeltoidMuscleConnector.Symmetry.DeltoidLateralWrap,
  NUMBER_OF_CYLINDERS= 4,
  DEBUG=0
  ) = 
  {     
    //       Radius = 0.04;
    //       RadiusHeight = 0.04;
    Radius = .Humerus.test_fitting_2.scaledlateral.Radius[1];
    RadiusX = .Humerus.test_fitting_2.scaledlateral.Radius[0];
    RadiusHeight = .Humerus.test_fitting_2.scaledlateral.Radius[2];
    Angles = ...Sign*{65, 85, 110, 140};
    Visibility = repmat(NumberOfCylinders, On);
    //         Visibility = {On, On, Off, Off, Off, Off};
  }; 
  
  MultiWrapSurfs CylindersAnterior (
  BASE_FRAME = .DeltoidMuscleConnector.Symmetry.DeltoidAnteriorWrap,
  NUMBER_OF_CYLINDERS= 4,
  TYPE="ELIPSOID",
  DEBUG=0
  ) = 
  {     
    //       Radius = 0.049;
    //       RadiusX = 0.06;
    //       RadiusHeight = 0.049;
    Radius = .Humerus.test_fitting_2.scaledanterior.Radius[1];
    RadiusX = .Humerus.test_fitting_2.scaledanterior.Radius[0];
    RadiusHeight = .Humerus.test_fitting_2.scaledanterior.Radius[2];
    Angles = ...Sign*({190, 200, 215, 225}-20);
    //         Angles = ...Sign*{190, 200, 215, 225};
    WrapSurfLength = 0.32;
    Visibility = repmat(NumberOfCylinders, On); 
    //       Visibility = {Off, Off, Off, Off, Off, On};
  };
  
  
  
  AnySeg DeltoidMuscleConnector ={

    //AnyDrawRefFrame drw ={ScaleXYZ={1,1,1};RGB={0,0,1};};

    AnyRefNode Symmetry = {
  //    AnyDrawRefFrame drw ={ScaleXYZ={1,1,1};RGB={0,1,1};};

      #if _LEFT_RIGHT_ == "LEFT"
        ARel = RotMat(pi,x)*RotMat(0.1,y);
       //  ARel = RotMat(-0.1,y);
      #else
        ARel =RotMat(-0.1,y);
      #endif
     
      AnyRefNode DeltoidAnteriorWrap = {
  
//        ARel = RotMat(.....Sign*-20*pi/180.0, y)*RotMat(7*pi/180.0, x);
        ARel = RotMat(.....Sign*-20*pi/180.0, y)*RotMat(7*pi/180.0, x);

      };
      
      AnyRefNode DeltoidLateralWrap = {};
      
      AnyRefNode DeltoidPosteriorWrap = {
        ARel = RotMat(.....Sign*40*pi/180.0, z)*RotMat(72*pi/180.0, x)*RotMat(-70*pi/180.0, x);
      };
      
    };
    
    
    AnyMat33  As= {
      {...Sign*...Seg.Humerus.Axes0[0][0],...Sign*...Seg.Humerus.Axes0[0][1],...Sign*...Seg.Humerus.Axes0[0][2]},
      {...Sign*...Seg.Humerus.Axes0[1][0],...Sign*...Seg.Humerus.Axes0[1][1],...Sign*...Seg.Humerus.Axes0[1][2]},
      {...Seg.Humerus.Axes0[2][0],...Seg.Humerus.Axes0[2][1],...Seg.Humerus.Axes0[2][2]}
    };
    
    r0=...Seg.Humerus.r0;  
    Axes0=As;
    
    AnyFunTransform3D &ScaleScapula=...Scaling.Scapula.ScaleFunction;
    AnyFunTransform3D &Scale=...Scaling.Humerus.ScaleFunction;
    
    
    
    Mass=0;
    Jii={0.0,0.0,0.0};
    
  };
  
  AnySphericalJoint DeltoidMuscleConnectorJnt ={
    AnySeg &ref1=.DeltoidMuscleConnector ;
    AnyRefNode &ref2=.Humerus.gh_rotated;
  };
  
  AnyReacForce DeltoidMuscleConnectorReactionForce={
    AnySphericalJoint &ref2=.DeltoidMuscleConnectorJnt;//.DeltoidMuscleConnectorHumerusRot;
  };

  
  AnyFolder &Scapula=..Seg.Scapula;
  Scapula={
    AnyRefNode gh_rotated={
      sRel=.gh.sRel;
      ARel={{....Sign*1,0,0},{0,1,0},{0,0,....Sign*1}};
    };
  };
  
  AnyFolder &Humerus =..Seg.Humerus;
  Humerus={
    AnyRefNode gh_rotated={
      sRel=.gh.sRel;
      ARel={{1,0,0},{0,....Sign*1,0},{0,0,....Sign*1}};
    };
  };
  
  AnyKinRotational HumerusDeltoidMuscleConnectorRot={
    AnyRefNode &ref1=.Scapula.gh_rotated;
    AnySeg &ref2=.DeltoidMuscleConnector;
    Type =RotAxesAngles;

  };
  
  AnyKinEqSimpleDriver drv = {
    AnyKinMeasure &u2 = .HumerusDeltoidMuscleConnectorRot;
    DriverPos={0,0,0};
    DriverVel={0,0,0};
    Reaction.Type={Off,Off,Off};  
    
  }; // Measure
  
  

  
  
};

