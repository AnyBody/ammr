#ifndef ROTATIONPENETRATIONCOMBIDRIVER_TEMPLATE_ANY
#define ROTATIONPENETRATIONCOMBIDRIVER_TEMPLATE_ANY
/*
---
group: Utilities
topic: Kinematic limits
descr: |
  Create a combination driver that drives a rotation to
  prevent penetration in a box.
---

To use these drivers import the file:
#include "<ANYBODY_PATH_MODELUTILS>/KinematicLimits/RotationPenetrationCombiDriver_template.any"

See below for more information on how to use the class.

*/

// This class template can be used to set up soft drivers that drive rotational and
// linear measures to ensure that the rotational measure is normally at zero unless it 
// deviates to prevent penetration of a target frame in a box shaped space. 
// 
// The driver sets up two soft drivers, therefore overdeterminate analysis is needed.
// The first driver is a weak driver to drive the neutral angle measure. The second
// driver is a strong soft driver that prevents penetration in the box space.
// 
// The box space is defined specifying 4 points in counter clockwise sense. These points
// are used to define a boundary where the penetration prevention constraint is active
// and the plane formed by the four points is used to create the threshold for 
// penetration. The positive direction is identified by the right hand rule
// through the 4 corner points, and negative direction is prevented. The penetration 
// check is done only on one plane. The box is, therefore, open on the other side. 
// 
// Use cases of such a combi driver can be flexion of toes in combination with the 
// presence of ground. The driver will ensure that the toes stay normally at their 
// neutral angle and extend only when necessary to prevent penetration with the floor,
// for e.g, at toe-off phase in gait. The corners can be used to create more complex
// scenarios like stairs.
// Another example could be to grab a box in combination with wrist flexion. The driver
// can be used to ensure that the wrist deviates from the neutral posture only when 
// penetration with the box must be avoided.
// 
// ## HOW TO USE:
// 
// The class template definition is already loaded through the libdef.any file. Simply use the
// `RotationPenetrationCombiDriver` class in your model.
// 
// In the following example we add a combination driver to `MyKinematicMeasure` and `MyTargetFrame`, which
// ensures neutral angle of the kinematic measure outside the box and prevents penetration of the target
// frame below the planar surface defined by the 4 corner points by allowing deviation in the kinematic 
// measure. 
// 
// :::{note} PLEASE ENSURE THAT THE TARGET FRAME IS ABOVE THE PENETRATION PLANE DEFINED BY THE CORNERS AND THE
// DEPTH LIMIT AT LOAD-TIME TO ENSURE KINEMATIC STABILITY.
// :::
// 
// :::{rubric} Example
// :::
// 
// ```{code-block} AnyScriptDoc
// 
// Main = {
// 
//   RotationPenetrationCombiDriver combo_driver(
//       NEUTRAL_ANGLE_MEASURE = ..path.to.MyKinematicMeasure,
//       TARGET_FRAME = ..path.to.MyTargetFrame,
//    ) = {
//          Corners = {
//                      {0.0, 0.0, 0.0},
//                      {0.0, 0.0, 0.5},
//                      {0.5, 0.0, 0.5},
//                      {0.5, 0.0, 0.0},
//                     };
//        }; 
//       
// ```
// 
#class_template RotationPenetrationCombiDriver (
  PLANE_BASE_FRAME = Main.EnvironmentModel.GlobalRef,
  NEUTRAL_ANGLE_MEASURE,
  TARGET_FRAME
  )
  {
    
// 
// The class supports the following settings:
// 
// |------------------------------|--------------|----------------------------------------------------------------------------------------------------------------------------|
// | Variable                     | Type         |  Default                        | Desciption                                                                               |
// |------------------------------|--------------|---------------------------------|------------------------------------------------------------------------------------------|
// | PLANE_BASE_FRAME             | AnyRefFrame  | Main.EnvironmentModel.GlobalRef | The base frame on which the corners are specified                                        |
// | NEUTRAL_ANGLE_MEASURE        | AnyKinMeasure|  -                              | Kinematic measure to be driven to neutral value                                          |
// | TARGET_FRAME                 | AnyRefFrame  |  -                              | Target frame that will be checked for penetration with base frame                        |
// | Corners                      | AnyMatrix    |  -                              | Matrix with coordinates of 4 corner points                                               |
// | UsePlaneBordersForBoundsCheck| AnyVar       | 1                               | Switch to use the 4 corners for detecting within bounds(=1), or use an infinite plane(=0)|
// | BoxVisibility                | AnySwitchVar | On                              | Switch to visualize lines connecting the 4 corners and the penetration plane             |
// | MeasureNeutralValue          | AnyVar       | 0.0                             | Neutral value for the NEUTRAL_ANGLE_MEASURE                                              |
// | WeightNeutralAngleDriver     | AnyVar       | 1e-5                            | Weak weight to drive the kinematic measure to neutral value                              |
// | WeightBoxDriver              | AnyVar       | 1.0                             | Weight of the driver preventing the penetration of the target frame                      |
// | WeightWithinBoundsFun        | AnyVar       | 1.0                             | Weight of function checking if target frame is within bounds of the 4 corners            |
// | DepthLowerLimit              | AnyVar       | 0.0                             | Depth limit, measured from the corners, at which the penetration constraint kicks in     |
// | DepthLowerLimitHard          | AnyVar       | DepthLowerLimit - 0.01;         | Hard depth limit, for ramping up the penetration penalty                                 |
// | ErrorAtDepthLowerLimitHard   | AnyVar       | 1.0                             | Error at the hard depth limit                                                            |
// |------------------------------|--------------|---------------------------------|------------------------------------------------------------------------------------------|
// 
    // Arguments
    // ------------
    // RotationPenetrationCombiDriver#PLANE_BASE_FRAME
    // The base frame on which the corners are specified
    // RotationPenetrationCombiDriver#NEUTRAL_ANGLE_MEASURE
    // Kinematic measure to be driven to neutral value 
    // RotationPenetrationCombiDriver#TARGET_FRAME
    // Target frame that will be checked for penetration with base frame 

    // RotationPenetrationCombiDriver
    /// Matrix with coordinates of 4 corner points
    #var AnyMatrix Corners;
    
    AnyFolder Settings = {
      // RotationPenetrationCombiDriver.Settings
      /// Switch to use the 4 corners for detecting within bounds (=1), or use an infinite plane (=0)
      #var AnyVar UsePlaneBordersForBoundsCheck = 1;
      
      // RotationPenetrationCombiDriver.Settings
      /// Switch to visualize lines connecting the 4 corners and the penetration plane
      #var AnySwitchVar BoxVisibility = On;
      
      // RotationPenetrationCombiDriver.Settings
      /// Neutral value for the NEUTRAL_ANGLE_MEASURE
      #var AnyVar MeasureNeutralValue = 0.0;
      
      // RotationPenetrationCombiDriver.Settings
      /// Weak weight to drive the kinematic measure to neutral value
      #var AnyVar WeightNeutralAngleDriver = 1e-5;
      
      // RotationPenetrationCombiDriver.Settings
      /// Weight of the driver preventing the penetration of the target frame
      #var AnyVar WeightBoxDriver = 1.0;
      
      // RotationPenetrationCombiDriver.Settings
      /// Weight of function checking if target frame is within bounds of the 4 corners
      #var AnyVar WeightWithinBoundsFun = 1.0;
      
      // RotationPenetrationCombiDriver.Settings
      /// Depth limit, measured from the corners, at which the penetration constraint kicks in
      #var AnyVar DepthLowerLimit = 0.0; 
      
      // RotationPenetrationCombiDriver.Settings
      /// Hard depth limit, for ramping up the penetration penalty
      #var AnyVar DepthLowerLimitHard = DepthLowerLimit - 0.01;
      
      // RotationPenetrationCombiDriver.Settings
      /// Error at the hard depth limit
      #var AnyVar ErrorAtDepthLowerLimitHard = 1.0;
    };
    
    AnyKinMeasure &NeutralAngleMeasure = NEUTRAL_ANGLE_MEASURE;
    AnyRefFrame &PlaneBaseFrame = PLANE_BASE_FRAME;
    AnyRefFrame &TargetFrame = TARGET_FRAME;
    
    AnyKinEqSimpleDriver NeutralAngleDriver = {
      AnyKinMeasure &Rot = .NeutralAngleMeasure;
      DriverPos = {.Settings.MeasureNeutralValue};
      DriverVel = {0};
      Reaction = {
        #var Type = {Off};
      };
      #var CType = {Soft};
      WeightFun = {&WeightConst};
      AnyFunConst WeightConst ={Value ={..Settings.WeightNeutralAngleDriver};};
    };
    
    AnyKinEqSimpleDriver BoxDriver = {
      AnyKinMeasure &Meas = .ConditionCheck.C0_C1_C2_C3_BelowSurface;
      DriverPos = {0};
      DriverVel = {0};
      Reaction = {
        #var Type = {Off};
      };
      #var CType = {Soft};
      WeightFun = {&WeightConst};
      AnyFunConst WeightConst ={Value ={..Settings.WeightBoxDriver};};
    };
    
    AnyFolder ConditionCheck ={
      
      AnyRefFrame &Object= .TargetFrame;   
      
      AnyRefFrame &PlaneBaseFrame = .PlaneBaseFrame;
      PlaneBaseFrame ={
        
        
        AnyRefNodeGroup Plane_##__NAME__ = {
          
          CreateMotionOutput.r=On;
          NodeDefaults.CreateMotionOutput.r=On;
          
          NodeAmount = 4;
          NodeName = "C"; // base name for
          Node_sRels = ...Corners;
          
          AnyRefNode MidNode = {
            sRel = mean(.Node_sRels');
            ARel = .Node_ARels[0];   
          };
          
          //draw outline
          AnyDrawPointCloud DrawCornerOutline = {
            Visible ??= ....Settings.BoxVisibility;
            Points = .Node_sRels;
            Points3D = On;
            RGB={0,0,1};
            PointStyle.Size=2.5*0.001;
            
            AnyIntArray bump = arrcat( iarr(1,.NodeAmount-1),0);
            VectorFields =take(.Node_sRels,bump,0)-.Node_sRels;
          };
          
          //draw penetration plane
          AnySurfTriMesh DrawPenetrationPlane = {
            Points = ....Corners + repmat(4,{{0,0,....Settings.DepthLowerLimit}*.MidNode.ARel'});
            Quadrilaterals = {{0,1,2,3}};
            viewSurface.Visible ??= ....Settings.BoxVisibility;
            viewSurface.Opacity = 0.3;
            viewSurface.RGB = {0,0,1};
          };
          
          Node_ARels = {
            RotMat(Node_sRels[0],Node_sRels[1],Node_sRels[2]),
            RotMat(Node_sRels[1],Node_sRels[2],Node_sRels[3]),
            RotMat(Node_sRels[2],Node_sRels[3],Node_sRels[0]),
            RotMat(Node_sRels[3],Node_sRels[0],Node_sRels[1])
          };
        };
      };
      
      AnyKinMeasureOrg Measures ={
        
        AnyKinLinear BoundsMeasure0 ={
          Ref=0;
          AnyRefFrame &ref=..PlaneBaseFrame.Plane_##__NAME__.C0;
          AnyRefFrame &ref2=..Object;
        };  
        AnyKinLinear BoundsMeasure1 ={
          Ref=0;    
          AnyRefFrame &ref=..PlaneBaseFrame.Plane_##__NAME__.C1;
          AnyRefFrame &ref2=..Object;
        };  
        AnyKinLinear BoundsMeasure2 ={
          Ref=0;
          AnyRefFrame &ref=..PlaneBaseFrame.Plane_##__NAME__.C2;
          AnyRefFrame &ref2=..Object;
        };  
        AnyKinLinear BoundsMeasure3 ={
          Ref=0;
          AnyRefFrame &ref=..PlaneBaseFrame.Plane_##__NAME__.C3;
          AnyRefFrame &ref2=..Object;
        };  
        MeasureOrganizer={0,3,6,9};
      }; // Measures
      
      AnyFunInterpol Fun ={
        T=farr(-10.0,0.01,20*100);
        Data={iffun(ltfun(T,0),
                    // When T<0, use WeightWithinBoundsFun if UsePlaneBordersForBoundsCheck is approx 0, otherwise set to 0.0
                    iffun(ltfun(abs(..Settings.UsePlaneBordersForBoundsCheck),0.00001), ..Settings.WeightWithinBoundsFun, 0.0),
                    // When T>=0, use WeightWithinBoundsFun
                    ..Settings.WeightWithinBoundsFun)};
        Type=Bspline;
      };
      
      
      AnyKinMeasureFunComb1 InSideBounds = {
        Functions={&.Fun,&.Fun,&.Fun,&.Fun};
        AnyKinMeasureOrg &ref=.Measures;
      };
      
      AnyKinMeasureQuadComb C0_C1 = {
        AnyKinMeasureOrg Measures ={
          AnyKinMeasure &ref=..InSideBounds;
          MeasureOrganizer={0,1};
        };
        OutDim = 1;
        Const={0};
        CoefQuadTensor  = {
          { {0,1},
            {0,0}
          }
        };
      };
      
      
      AnyKinMeasureQuadComb C0_C1_C2 = {
        AnyKinMeasureQuadComb &ref1=.C0_C1; 
        AnyKinMeasureOrg Measures ={
          AnyKinMeasure &ref2=..InSideBounds;
          MeasureOrganizer={2};
        };
        OutDim = 1;
        Const={0};
        CoefQuadTensor  = {
          { {0,1},
            {0,0}
          }
        };
      };
      
      AnyKinMeasureQuadComb C0_C1_C2_C3 = {
        AnyKinMeasureQuadComb &ref1=.C0_C1_C2; 
        AnyKinMeasureOrg Measures ={
          AnyKinMeasure &ref2=..InSideBounds;
          MeasureOrganizer={3};
        };
        OutDim = 1;
        Const={0};
        CoefQuadTensor  = {
          { {0,1},
            {0,0}
          }
        };
      };  
      
      AnyKinMeasureOrg Depth ={
        AnyKinLinear BoundsMeasure0 ={
          Ref=0;
          AnyRefFrame &ref=..PlaneBaseFrame.Plane_##__NAME__.C0;
          AnyRefFrame &ref2=..Object;
        };  
        MeasureOrganizer ={2};
      }; 
      // Send warning if load-time position of target frame is below the penetration plane (both conditions must fail)
      AnyInt DepthTest = warn(iffun(eqfun(System.LoadedModel.LoadComplete, "Off"),
                                orfun(
                                      // check if target frame is outside the bounds from the corners, considering its weight function
                                      ltfun(abs(C0_C1_C2_C3.Pos[0]),0.00001*.Settings.WeightWithinBoundsFun^4),
                                      // check if target frame is above the penetration plane
                                      gteqfun(Depth.Pos[0],.Settings.DepthLowerLimit)
                                      ),
                                  1),
      strformat("\n"+
      "------------------------------------------------------------------------------------------------------\n"+
      "WARNING: The target frame is located below the penetration plane as calculated from the corners \n"+
      "and the lower depth limit. Please update the load time position of the target frame or the\n"+ 
      "settings (Corners, DepthLowerLimit) to ensure the target frame is above the penetration plane, \n"+
      "and therefore, kinematic stability.\n"+
      "------------------------------------------------------------------------------------------------------"));
      
      AnyFunInterpol FunDepth ={
        T=farr(-10.0,0.001,20*1000);
        Data={..Settings.ErrorAtDepthLowerLimitHard*smoothramp(..Settings.DepthLowerLimit,..Settings.DepthLowerLimitHard,T)};
        Type=Bspline;
      };
      
      AnyKinMeasureFunComb1 BelowSurface = {
        Functions={&.FunDepth};
        AnyKinMeasureOrg &ref=.Depth;
      };
      
      AnyKinMeasureQuadComb C0_C1_C2_C3_BelowSurface = {
        AnyKinMeasure &ref1=.C0_C1_C2_C3; 
        AnyKinMeasure &ref2=.BelowSurface;
        OutDim = 1;
        Const={0};
        CoefQuadTensor  = {
          { {0,1},
            {0,0}
          }
        };
      };      
    }; // Condition Check

  };


#endif // ROTATIONPENETRATIONCOMBIDRIVER_TEMPLATE_ANY