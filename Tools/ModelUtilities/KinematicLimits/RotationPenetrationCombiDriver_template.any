/*

This class template can be used to set up soft drivers that drive rotational and
linear measures to ensure that the rotational measure is normally at zero unless it 
deviates to prevent penetration of a target frame in a box shaped space. 

The driver sets up two soft drivers, therefore overdeterminate analyis is needed.
The first driver is a weak driver to drive the neutral angle measure. The second
driver is a strong soft driver that prevents penetration in the box space.

The box space is defined specifying 4 points in counter clockwise sense. These points
are used to define a boundary where the penetration prevention constraint is active
and the plane formed by the four points is used to create the threshold for 
penetration. The positive direction is identified by the right hand rule
through the 4 corner points, and negative direction is prevented. The penetration 
check is done only on one plane. The box is, therefore, open on the other side. 

Use cases of such a combi driver can be flexion of toes in combination with the 
presence of ground. The driver will ensure that the toes stay normally at their 
neutral angle and extend only when necessary to prevent penetration with the floor,
for e.g, at toe-off phase in gait. The corners can be used to create more complex
scenarios like stairs.
Another example could be to grab a box in combination with wrist flexion. The driver
can be used to ensure that the wrist deviates from the neutral posture only when 
penetration with the box must be avoided.

HOW TO USE:

Add `#include "<ANYBODY_PATH_MODELUTILS>/KinematicLimits/RotationPenetrationCombiDriver_template.any"`
in your main file, after libdef.any has been included. Then create the `RotationPenetrationCombiDriver` 
class inside Main.

In the following example we add a combination driver to `MyKinematicMeasure` and `MyTargetFrame`, which  
ensures neutral angle of the kinematic measure outside the box and prevents penetration of the target
frame below the planar surface defined by the 4 corner points by allowing deviation in the kinematic 
measure. 

```
#include "libdef.any"
#include "<ANYBODY_PATH_MODELUTILS>/KinematicLimits/RotationPenetrationCombiDriver_template.any"

Main = {

  RotationPenetrationCombiDriver combo_driver(
      NEUTRAL_ANGLE_MEASURE = ..path.to.MyKinematicMeasure,
      TARGET_FRAME = ..path.to.MyTargetFrame,
   ) = {
         Corners = {
                     {0.0, 0.0, 0.0},
                     {0.0, 0.0, 0.5},
                     {0.5, 0.0, 0.5},
                     {0.5, 0.0, 0.0},
                    };
       }; 
      
```

The class supports the following settings:

|------------------------------|--------------|-----------------------------------------------------------------------------------------------------------------------|
| Variable                     | Type         |  Default                        | Desciption                                                                          |
|------------------------------|--------------|---------------------------------|-------------------------------------------------------------------------------------|
| PLANE_BASE_FRAME             | AnyRefFrame  | Main.EnvironmentModel.GlobalRef | The base frame on which the corners are specified                                   |
| NEUTRAL_ANGLE_MEASURE        | AnyKinMeasure|  -                              | Kinematic measure to be driven to neutral value                                     |
| TARGET_FRAME                 | AnyRefFrame  |  -                              | Target frame that will be checked for penetration with base frame.                  |
| Corners                      | AnyMatrix    |  -                              | Matrix with coordinates of 4 corner points                                          |
| UsePlaneBordersForBoundsCheck| AnyVar       | 1                               | Switch use the 4 corners for detecting within bounds, or use an infinite plane      |
| BoxVisibility                | AnySwitchVar | On                              | Switch to visualize lines connecting the 4 corners                                  |
| MeasureNeutralValue          | AnyVar       | 0.0                             | Neutral value for the NEUTRAL_ANGLE_MEASURE                                         |
| WeightNeutralAngleDriver     | AnyVar       | 1e-5                            | Weak weight to drive the kinematic measure to neutral value                         |
| WeightBoxDriver              | AnyVar       | 1.0                             | Weight of the driver preventing the penetration of the target frame                 |
| WeightWithinBoundsFun        | AnyVar       | 1.0                             | Weight of function checking if target frame is within bounds of the 4 corners       |
| DepthLowerLimit              | AnyVar       | 0.0                             | Depth limit, measured from the corners, at which the penetration constraint kicks in|
| DepthLowerLimitHard          | AnyVar       | DepthLowerLimit - 0.01;         | Hard depth limit, for ramping up the penetration penalty                            |
| ErrorAtDepthLowerLimitHard   | AnyVar       | 1.0                             | Error at the hard depth limit                                                       |
|------------------------------|--------------|---------------------------------|-------------------------------------------------------------------------------------|

*/

#class_template RotationPenetrationCombiDriver (
  PLANE_BASE_FRAME = Main.EnvironmentModel.GlobalRef,
  NEUTRAL_ANGLE_MEASURE,
  TARGET_FRAME)
  {
    #var AnyMatrix Corners;
    AnyFolder Settings = {
      #var AnyVar UsePlaneBordersForBoundsCheck = 1;
      #var AnySwitchVar BoxVisibility = On;
      #var AnyVar MeasureNeutralValue = 0.0;
      #var AnyVar WeightNeutralAngleDriver = 1e-5;
      #var AnyVar WeightBoxDriver = 1.0;
      #var AnyVar WeightWithinBoundsFun = 1.0;
      #var AnyVar DepthLowerLimit = 0.0; 
      #var AnyVar DepthLowerLimitHard = DepthLowerLimit - 0.01;
      #var AnyVar ErrorAtDepthLowerLimitHard = 1.0;
    };
    
    AnyKinMeasure &NeutralAngleMeasure = NEUTRAL_ANGLE_MEASURE;
    AnyRefFrame &PlaneBaseFrame = PLANE_BASE_FRAME;
    AnyRefFrame &TargetFrame = TARGET_FRAME;
    
    AnyKinEqSimpleDriver NeutralAngleDriver = {
      AnyKinMeasure &Rot = .NeutralAngleMeasure;
      DriverPos = {.Settings.MeasureNeutralValue};
      DriverVel = {0};
      Reaction = {
        #var Type = {Off};
      };
      #var CType = {Soft};
      WeightFun = {&WeightConst};
      AnyFunConst WeightConst ={Value ={..Settings.WeightNeutralAngleDriver};};
    };
    
    AnyKinEqSimpleDriver BoxDriver = {
      AnyKinMeasure &Meas = .ConditionCheck.C0_C1_C2_C3_BelowSurface;
      DriverPos = {0};
      DriverVel = {0};
      Reaction = {
        #var Type = {Off};
      };
      #var CType = {Soft};
      WeightFun = {&WeightConst};
      AnyFunConst WeightConst ={Value ={..Settings.WeightBoxDriver};};
    };
    
    AnyFolder ConditionCheck ={
      
      AnyRefFrame &Object= .TargetFrame;   
      
      AnyRefFrame &PlaneBaseFrame = .PlaneBaseFrame;
      PlaneBaseFrame ={
        
        
        AnyRefNodeGroup Plane_##__NAME__ = {
          
          CreateMotionOutput.r=On;
          NodeDefaults.CreateMotionOutput.r=On;
          
          NodeAmount = 4;
          NodeName = "C"; // base name for
          Node_sRels = ...Corners;
          
          AnyRefNode MidNode = {
            sRel = mean(.Node_sRels');
            ARel = .Node_ARels[0];   
          };
          
          //draw outline
          AnyDrawPointCloud DrawVector = {
            Visible = ....Settings.BoxVisibility;
            Points = .Node_sRels;
            Points3D = On;
            RGB={0,0,1};
            PointStyle.Size=2.5*0.001;
            
            AnyIntArray bump = arrcat( iarr(1,.NodeAmount-1),0);
            VectorFields =take(.Node_sRels,bump,0)-.Node_sRels;
          };
          

          Node_ARels = {
            RotMat(Node_sRels[0],Node_sRels[1],Node_sRels[2]),
            RotMat(Node_sRels[1],Node_sRels[2],Node_sRels[3]),
            RotMat(Node_sRels[2],Node_sRels[3],Node_sRels[0]),
            RotMat(Node_sRels[3],Node_sRels[0],Node_sRels[1])
          };
        };         
      };
      
      AnyKinMeasureOrg Measures ={
        
        AnyKinLinear BoundsMeasure0 ={
          Ref=0;
          AnyRefFrame &ref=..PlaneBaseFrame.Plane_##__NAME__.C0;
          AnyRefFrame &ref2=..Object;
        };  
        AnyKinLinear BoundsMeasure1 ={
          Ref=0;    
          AnyRefFrame &ref=..PlaneBaseFrame.Plane_##__NAME__.C1;
          AnyRefFrame &ref2=..Object;
        };  
        AnyKinLinear BoundsMeasure2 ={
          Ref=0;
          AnyRefFrame &ref=..PlaneBaseFrame.Plane_##__NAME__.C2;
          AnyRefFrame &ref2=..Object;
        };  
        AnyKinLinear BoundsMeasure3 ={
          Ref=0;
          AnyRefFrame &ref=..PlaneBaseFrame.Plane_##__NAME__.C3;
          AnyRefFrame &ref2=..Object;
        };  
        MeasureOrganizer={0,3,6,9};
      }; // Measures
      
      AnyFunInterpol Fun ={
        T=farr(-10.0,0.01,20*100);
        Data={iffun(ltfun(T,0),1.0-..Settings.UsePlaneBordersForBoundsCheck,..Settings.WeightWithinBoundsFun)};
        Type=Bspline;
      };

      
      AnyKinMeasureFunComb1 InSideBounds = {
        Functions={&.Fun,&.Fun,&.Fun,&.Fun};
        AnyKinMeasureOrg &ref=.Measures;
      };
      
      AnyKinMeasureQuadComb C0_C1 = {
        AnyKinMeasureOrg Measures ={
          AnyKinMeasure &ref=..InSideBounds;
          MeasureOrganizer={0,1};
        };
        OutDim = 1;
        Const={0};
        CoefQuadTensor  = {
          { {0,1},
            {0,0}
          }
        };
      };
      
      
      AnyKinMeasureQuadComb C0_C1_C2 = {
        AnyKinMeasureQuadComb &ref1=.C0_C1; 
        AnyKinMeasureOrg Measures ={
          AnyKinMeasure &ref2=..InSideBounds;
          MeasureOrganizer={2};
        };
        OutDim = 1;
        Const={0};
        CoefQuadTensor  = {
          { {0,1},
            {0,0}
          }
        };
      };
      
      AnyKinMeasureQuadComb C0_C1_C2_C3 = {
        AnyKinMeasureQuadComb &ref1=.C0_C1_C2; 
        AnyKinMeasureOrg Measures ={
          AnyKinMeasure &ref2=..InSideBounds;
          MeasureOrganizer={3};
        };
        OutDim = 1;
        Const={0};
        CoefQuadTensor  = {
          { {0,1},
            {0,0}
          }
        };
      };  
      
      AnyKinMeasureOrg Depth ={
        AnyKinLinear BoundsMeasure0 ={
          Ref=0;
          AnyRefFrame &ref=..PlaneBaseFrame.Plane_##__NAME__.C0;
          AnyRefFrame &ref2=..Object;
        };  
        MeasureOrganizer ={2};
      }; 
      
      AnyFunInterpol FunDepth ={
        T=farr(-10.0,0.001,20*1000);
        Data={..Settings.ErrorAtDepthLowerLimitHard*smoothramp(..Settings.DepthLowerLimit,..Settings.DepthLowerLimitHard,T)};
        Type=Bspline;
      };
      
      AnyKinMeasureFunComb1 BelowSurface = {
        Functions={&.FunDepth};
        AnyKinMeasureOrg &ref=.Depth;
      };
      
      AnyKinMeasureQuadComb C0_C1_C2_C3_BelowSurface = {
        AnyKinMeasure &ref1=.C0_C1_C2_C3; 
        AnyKinMeasure &ref2=.BelowSurface;
        OutDim = 1;
        Const={0};
        CoefQuadTensor  = {
          { {0,1},
            {0,0}
          }
        };
      };      
    }; // Condition Check

  };