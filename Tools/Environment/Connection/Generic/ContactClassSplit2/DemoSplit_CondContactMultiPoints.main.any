#include "../../../../libdef.any"
#include "EllipticCylinderPointsGrid.any"
#include "Split/FMM2.any"
#include "Split/DrawResultant.any"

#include "Split/KinMsrClass.any"
#include "Split/CylContDetClass.any"
#include "Split/CylContDetClass2.any"
#include "Split/ContactConditionSmoothingClass.any"
#include "Split/ContactConditionSmoothingClass2.any"
#include "Split/CreateContactElementClass.any"
#include "Split/CreateContactElementClass2.any"
#include "Split/RepeaterCT.any"


//#include "ConditionalContactMultiPoints.any"
//#include "ConditionalContactDistanceAndVelocityDepClass.any"

/**
This model demonstrates a simple application of the class template
ConditionalContactMultiPoints. This class creates conditional
contact elements between nodes on the base object (base nodes) and 
nodes on the target object (target nodes). The contact elements are
created indvidually between corresponding nodes on the two objects.
That is, between <BaseObject>.Node0 and <TargetObject>.Node0, then 
between <BaseObject>.Node1 and <TargetObject>.Node1, and so on. 
This allows each node to have a unique orientation that can be used 
to define the normal and frictional directions for the contact 
elements. 

The model consists of two segments. The first segment is grounded
to the global ref using AnyStdJnt that simulates the reaction forces
between the ground and the first segment. The second segment is 
defined to be in contact with the first segment. The contact nodes
are generated using the EllipticCylinderPointsGrid class template, 
which allows parametrization of the contact points.

The model consists of different forces applied to the second segment
to visualize the force generated by the contact elements and the 
resultant force. There are two rotating force in the YZ and XZ plane. 
There is a constant force acting in -Y direction. Lastly, there is 
the gravitational force that will consider the weight of the second
segment. 

The conditional contact class will consider all the forces acting 
on the second segment.
*/
Main = {
  // Create folder with Draw Settings. These valuese are used by
  // the ConditionalContactMultiPoints class. This folder is 
  // generated normally whenever a human model is present in the
  // model.
  Template_DrawSettings DrawSettings = {}; 
  AnyFolder Model = {
    // -----------------------------------------------------
    // Basic Reference Frames (Global Ref)
    // -----------------------------------------------------
    AnyFixedRefFrame GlobalRef = {
      AnyRefNode N1 = {
        sRel = {0.2,0.1,0};
      };
      AnyDrawRefFrame DrwGlobalRef = {ScaleXYZ = 0.3*{1,1,1};};    
    };
    
    // -----------------------------------------------------
    // Segments
    // -----------------------------------------------------   
    // Create two segments      
    
      AnySeg Seg1 = {
        r0 = {0.2,0.1,0.0};
        Mass = 20.0;
        Jii = {0.05,0.1,0.1};
//        AnyDrawSeg DrwSeg= { RGB = {1,0,0};Opacity = 0.2;};
      }; // seg1

      AnySeg Seg2 = {
        r0 = {0.2,0.1,0.0};
        Mass = 10.0;
        Jii = {0.05,0.1,0.1};
        AnyRefNode LoadNode = {sRel = {0.5,0.0,0};};        
        AnyDrawSeg DrwSeg= { RGB = {0,1,0};Opacity = 0.2;};
      }; // seg2         

      
    // -----------------------------------------------------
    // Joints
    // -----------------------------------------------------
    
    AnyFolder Joints = {
      // Joint between Seg1 and Global ref
      AnyStdJoint JntS1 = {
        AnyRefNode &Ground = Main.Model.GlobalRef.N1;
        AnySeg &Seg = Main.Model.Seg1;
        // Reaction forces between S1 and ground are enabled by default
      };
      
      // Joint between Seg2 and Global ref. Note, reactions from the joint
      // are disabled. These will be provided by the contact elements
//      AnyStdJoint JntS2 = {
//        AnyRefFrame &Ground = Main.Model.GlobalRef.N1;
//        AnySeg &Seg = Main.Model.Seg2;
//        // Switch off reaction forces between S2 and ground
//        Constraints.Reaction.Type = repmat(6,Off);
//      };
      
      AnyCylindricalJoint JntS2 = {
        AnyRefFrame &Ground = Main.Model.GlobalRef.N1;
        AnySeg &Seg = Main.Model.Seg2;
        Axis = x;
        // Switch off reaction forces between S2 and ground
        Constraints.Reaction.Type = repmat(Constraints.nDim,Off);
      };
      
      AnyKinEqSimpleDriver rotation = {
      AnyJoint &Jnt = .JntS2;
      DriverPos = {0,0};
      DriverVel = {0.0, 0*pi/180};
};
      
    }; // Joints
    
    
    // -----------------------------------------------------
    // Force and Contact Model
    // -----------------------------------------------------
    // Three different external loads and the contact model 
    // are defined here.

    AnyFolder Kinetics = {   
      AnyFloat tStart = Main.Study.tStart;
      AnyFloat tEnd = Main.Study.tEnd;
      AnyFloat tSim = tEnd - tStart;
      // Rotating force on Seg2 in YZ plane for first half interval
      AnyForce3D ForceYZPlane = {
        AnyRefFrame &Seg2 = Main.Model.Seg2.LoadNode;        
        F = iffun(ltfun(t,.tStart+0.5*.tSim),300*{0,sin(2*(t-.tStart)*2*pi/.tSim),cos(2*(t-.tStart)*2*pi/.tSim)},{0.0,0.0,0.0});
        AnyDrawForce drw = {};
      };
      // Rotating force on Seg2 in XZ plane for second half interval
      AnyForce3D ForceXZPlane = {
        AnyRefFrame &Seg2 = Main.Model.Seg2.LoadNode;
        F = iffun(gtfun(t,.tStart+0.5*.tSim),300*{sin(2*(t-.tStart)*2*pi/.tSim),0,cos(2*(t-.tStart)*2*pi/.tSim)},{0.0,0.0,0.0});
        AnyDrawForce drw = {};
      };
      // Static Force on Seg2 
      AnyForce3D StaticForce = {
        AnyRefFrame &Seg2 = Main.Model.Seg2.LoadNode;
        F = {0,-200,0};
        AnyDrawForce drw = {};
      };
      
      // Contact model between Seg2 and Seg1. 
      AnyFolder ContClassSplit = {
        AnyFolder Points = {
          EllipticCylinderPointsGrid SplitBaseNodes (
          CENTER_FRAME = Main.Model.Seg2,
          AXIS = "X") = {
            Length = 0.20;
            Maj_ax = 0.10 + 0.0;
            Min_ax = 0.08 + 0.0;
            nRows = 4;
            nCols = 4;
          };
          
          EllipticCylinderPointsGrid SplitTargetNodes (
          CENTER_FRAME = Main.Model.Seg1,
          AXIS = "X") = {
            Length = 0.20;
            Maj_ax = 0.10;
            Min_ax = 0.08;
            nRows = .SplitBaseNodes.nRows;
            nCols = .SplitBaseNodes.nCols; Settings.NodesRotOffset = RotMat(0*pi/180,x);
          };
          AnyInt nPoints = SplitBaseNodes.nRows*SplitBaseNodes.nCols;
        }; // Points 
        
        
        AnyFolder InitializationArgs = {
          AnyVar UserDefinedDistLimitLow = -0.01;
          AnyVar UserDefinedDistLimitHigh = 0.01;
          AnyVar UserDefinedRadiusLimit=0.02;
          AnyVar UserDefinedVelLimitHigh= 0.8;
          AnyVec3 UserDefinedGroundVel = {0.0,0.0,0};
          AnyVar Strength = 500;
          AnyVar StaticFrictionCoefficient = 0.5;
          AnyVar ScaleFactor = 1;
        };
        
        AnyFolder KinMeasures = {
//          AnyInt dimMeasure = SizesOf(MeasuresOrg.Pos)[0];
//          AnyInt normals = iarr(0,3,dimMeasure-3);
//          AnyInt friction1 = iarr(1,3,dimMeasure-2);
//          AnyInt friction2 = iarr(2,3,dimMeasure-1);
//          
//          AnyFloat NormalPos = take(MeasuresOrg.Pos,normals);
//          AnyFloat Friction1Pos = take(MeasuresOrg.Pos,friction1);
//          AnyFloat Friction2Pos = take(MeasuresOrg.Pos,friction2);

          AnyKinMeasureOrg MeasuresOrg = {
          AnyInt dimMeasure = SizesOf(Pos)[0];
          AnyInt normals = iarr(0,3,dimMeasure-3);
          AnyInt friction1 = iarr(1,3,dimMeasure-2);
          AnyInt friction2 = iarr(2,3,dimMeasure-1);
          
          AnyFloat NormalPos = take(Pos,normals);
          AnyFloat Friction1Pos = take(Pos,friction1);
          AnyFloat Friction2Pos = take(Pos,friction2);

          AnyFloat NormalVel = take(Vel,normals);
          AnyFloat Friction1Vel = take(Vel,friction1);
          AnyFloat Friction2Vel = take(Vel,friction2);
          
//          AnyObjectPtr Vels = ObjSearch("Lin*.ref.Vel");
//          AnyObjectPtr Vels2 = ObjSearchRecursive(CompleteNameOf(&), "*.ref.Vel","AnyFloat",3);
         
          };
          CreateManySubTemplates Measures (
          NUM=16,
          T_NAME= "KinMsrClass",
          NAME_PREFIX="",
          ARG1=...Points.SplitBaseNodes.CenterFrame.SplitBaseNodes,
          ARG2=...Points.SplitTargetNodes.CenterFrame.SplitTargetNodes,
          ARG3=AnyKinLinear, 
          ARG4=..MeasuresOrg,
          ARG5="Y"
          //        ARG_INI_SWITCH = 1,
          //        ARG_INI =..InitializationArgs
          )={};
        };
        
        AnyFolder ContDetect = {
          AnyInt f = 16;
          
          
          CylContDetClass2 ContCheck (
          ARG1 = Main.Model.Kinetics.ContClassSplit.KinMeasures.MeasuresOrg,
          ARG_INI_SWITCH = 1,
          ARG_INI =..InitializationArgs) = {};
          
          CreateManySubTemplates ContDet (
          NUM=16,
          T_NAME= "CylContDetClass",
          NAME_PREFIX="",
          ARG1=...KinMeasures.Measures,
          ARG2="",
          ARG3=1,
          ARG4=1,
          ARG5="Y",
          ARG_INI_SWITCH = 1,
          ARG_INI =...InitializationArgs
          )={};
        };
        AnyFolder ContDetectSmooth = {
          ContactConditionSmoothing2 RadiusSmoothing (
          ARG1="FUNC_PROFILE_LINEAR",
          ARG2=..ContDetect.ContCheck.RadiusRatio,
          ARG3=1.0,
          ARG4=0.9) = {};
          
          ContactConditionSmoothing2 HeightSmoothing (
          ARG1="FUNC_PROFILE_LINEAR",
          ARG2=..ContDetect.ContCheck.HeightRatio,
          ARG3=1.0,
          ARG4=0.8) = {};

          ContactConditionSmoothing2 VelocitySmoothing (
          ARG1="FUNC_PROFILE_LINEAR",
          ARG2=..ContDetect.ContCheck.VelRatio,
          ARG3=1.0,
          ARG4=0.15) = {};

          AnyFloat SmoothingFun = mult(mult(RadiusSmoothing.SmoothingFun,HeightSmoothing.SmoothingFun),VelocitySmoothing.SmoothingFun);

          CreateManySubTemplates ContDetSmoothing (
          NUM=16,
          T_NAME= "ContactConditionSmoothing",
          NAME_PREFIX="",
          ARG1="FUNC_PROFILE_LINEAR",
          ARG2=Main.Model.Seg1.SplitTargetNodes,
          ARG3=0,
          ARG4=0,
          ARG5="Y",
          ARG_INI_SWITCH = 1,
          ARG_INI =...ContDetect.ContDet
          )={};
        };
        AnyFolder ContElements = {
          CreateManySubTemplates ContEles (
          NUM=16,
          T_NAME= "CreateContactElements2",
          NAME_PREFIX="",
          ARG1=...KinMeasures.Measures,
          ARG2=...ContDetect.ContDet,
//          ARG3=0,
//          ARG4=0,
          ARG5=...ContDetectSmooth.SmoothingFun,
          ARG_INI_SWITCH = 1,
          ARG_INI =...InitializationArgs
          )={};

//          CreateManySubTemplates ContEles (
//          NUM=16,
//          T_NAME= "CreateContactElements",
//          NAME_PREFIX="",
//          ARG1=...KinMeasures.Measures,
//          ARG2=...ContDetect.ContDet,
////          ARG3=0,
////          ARG4=0,
//          ARG5=...ContDetectSmooth.ContDetSmoothing,
//          ARG_INI_SWITCH = 1,
//          ARG_INI =...InitializationArgs
//          )={};
        };
        
        AnyFolder ResultantForce = {
          
          FMM2 fmm (
          BASE_FRAME =Main.Model.Seg2,
          BASE_SEG = Main.Model.Seg2,
          FORCE_FOLDER = ..ContElements.ContEles) = {}; 
          
        };
        
        AnyFolder Visualization = {
          DrawResultant DrawFMM (
          ARG1 = Main.Model.Seg2,
          ARG2 = ..ResultantForce.fmm.FLocal,
          ARG3 = ..ResultantForce.fmm.MLocal
          ) ={
            //  FLocal = ..ResultantForce.fmm.FLocal;
            //  MLocal = ..ResultantForce.fmm.MLocal;
          };
        };
        
        
      }; // ContClassSplit
      
      
      
      
      
      // Please see also the class template for detailed definitions
      // of the class arguments
      // #include "<ANYBODY_PATH_AMMR>/Tools/Environment/Connection/Generic/Kinetics/ContactElements/ConditionalContactMultiPoints.any"
////      ConditionalContactMultiPoints ContactS2S1(
////      BASE_FRAME = Main.Model.Seg2,
////      BASE_NODES_FOLDER = Main.Model.Seg2.BaseNodes,
////      BASE_SEG = Main.Model.Seg2,
////      // NORMAL_DIRECTION specifes the normal for the contact elements.
////      // It refers to the normal direction of the base nodes.
////      NORMAL_DIRECTION = "Y",
////      TARGET_NODES_FOLDER = Main.Model.Seg1.TargetNodes,
////      NUMBER_OF_NODES = 36,
////      SHOW_TRIGGER_VOLUME = 1
////      ) =
////      {
////        // The contents of the Settings folder are optional and need
////        // not be be specified as the class specifies default values. 
////        // But you can change these values to suit your model.
////        Settings = { 
////          // Options for contact detection thresholds
////          LimitDistLow = -0.01;
////          LimitDistHigh = 0.01;
////          Radius = 0.02;
////          LimitVelHigh = 0.8;
////          // Strength of the contact elements.
////          Strength = 2000; 
////          // Friction coefficient
////          FrictionCoefficient = 0.5; 
////          // Options for scaling the drawing of the force vectors
////          ElementForceDrawScaleFactor = 1;
////          ResultantForceDrawScaleFactor = 1;
////          ResultantMomentDrawScaleFactor = 1;
////        };
////        
////        // The contact nodes required by the ConditionalContactMultiPoints 
////        // class are defined below using the EllipticCylinderPointsGrid
////        // class. The contact nodes can be defined else where in the model
////        // by the user and by other methods also. The requirement is that
////        // the base and target nodes folder point to the folder containing
////        // the contact nodes. The nodes are named Node0, Node1, Node2, etc. 
////        // And, the NUMBER_OF_NODES is equal to (or less than) the number
////        // of nodes in the base and target folders.
////
////        // The EllipticCylinderPointsGrid class creates a grid of nodes 
////        // in an elliptical cylinder shape with their reference frames
////        // oriented to be tangential to the ellipse and parallel to the 
////        // cylinder axis with the normal pointing inwards. Please see the 
////        // class template and its demo for more details. 
////        // #include "<ANYBODY_PATH_AMMR>/Tools/Environment/Connection/Generic/PointsGenerator/EllipticCylinderPointsGrid.any"
////        EllipticCylinderPointsGrid BaseNodes (
////        CENTER_FRAME = Main.Model.Seg2,
////        AXIS = "X") = {
////          Length = 0.20;
////          Maj_ax = 0.10;
////          Min_ax = 0.08;
////          nRows = 3;
////          nCols = 12;
////        };
////        
////        EllipticCylinderPointsGrid TargetNodes (
////        CENTER_FRAME = Main.Model.Seg1,
////        AXIS = "X") = {
////          Length = 0.20;
////          Maj_ax = 0.10;
////          Min_ax = 0.08;
////          nRows = 3;
////          nCols = 12;
////        };
////      }; // ContactS2S1
    
    }; // Kinetics
    
  }; // Model
  
  AnyBodyStudy Study = {
    AnyFolder& Model = Main.Model;
    Gravity = {0,-9.81,0};    
    nStep = 100;
    tEnd= 20;
  };
  
  // Switch to define an automatic save of results to the Output folder
  #ifndef AutoSaveOption 
  #define AutoSaveOption 0
  #endif
  
  /**Execute this operation to run the model in the intended operation sequence.  
  It is also possible to run operations seperately, by manual selections in the operation tree*/
  AnyOperationSequence RunApplication = {
    
    ///This operation is the inverse dynamic analysis
    AnyOperation &InvAnal=Main.Study.InverseDynamics;
    
    #if AutoSaveOption 
    /// This operation saves the output of the study to an h5 file in the Output folder
    AnyOperationMacro save = {
      MacroStr={ "classoperation Main.Study.Output " + strquote("Save data") + " --type=Deep" + " --file="+ strquote(ANYBODY_PATH_OUTPUT + ANYBODY_NAME_MAINFILE + ".anydata.h5")};
    };
    #endif
  };  
  

  
};
