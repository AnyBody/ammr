#include "../../../../libdef.any"
//////#include "EllipticCylinderPointsGrid.any"
//////#include "Split/FMM2.any"
//////#include "Split/DrawResultant.any"
//////
#include "Split/KinMsrClass.any"
////////#include "Split/CylContDetClass.any"
#include "Split/CylContDetClass2.any"
////////#include "Split/ContactConditionSmoothingClass.any"
#include "Split/ContactConditionSmoothingClass2.any"
////////#include "Split/CreateContactElementClass.any"
////////#include "Split/CreateContactElementClass2.any"
//////#include "Split/CreateContactElementClass3.any"
#include "Split/RepeaterCT.any"


//#include "ConditionalContactMultiPoints.any"
//#include "ConditionalContactDistanceAndVelocityDepClass.any"

/**
This model demonstrates a simple application of the class template
ConditionalContactMultiPoints. This class creates conditional
contact elements between nodes on the base object (base nodes) and 
nodes on the target object (target nodes). The contact elements are
created indvidually between corresponding nodes on the two objects.
That is, between <BaseObject>.Node0 and <TargetObject>.Node0, then 
between <BaseObject>.Node1 and <TargetObject>.Node1, and so on. 
This allows each node to have a unique orientation that can be used 
to define the normal and frictional directions for the contact 
elements. 

The model consists of two segments. The first segment is grounded
to the global ref using AnyStdJnt that simulates the reaction forces
between the ground and the first segment. The second segment is 
defined to be in contact with the first segment. The contact nodes
are generated using the EllipticCylinderPointsGrid class template, 
which allows parametrization of the contact points.

The model consists of different forces applied to the second segment
to visualize the force generated by the contact elements and the 
resultant force. There are two rotating force in the YZ and XZ plane. 
There is a constant force acting in -Y direction. Lastly, there is 
the gravitational force that will consider the weight of the second
segment. 

The conditional contact class will consider all the forces acting 
on the second segment.
*/
Main = {
  // Create folder with Draw Settings. These valuese are used by
  // the ConditionalContactMultiPoints class. This folder is 
  // generated normally whenever a human model is present in the
  // model.
  Template_DrawSettings DrawSettings = {}; 
  AnyFolder Model = {
    // -----------------------------------------------------
    // Basic Reference Frames (Global Ref)
    // -----------------------------------------------------
    AnyFixedRefFrame GlobalRef = {
      AnyRefNode N1 = {
        sRel = {0.5,0.0,0};
      };
      AnyRefNode N2 = {
        sRel = {1.0,0.0,0};
      };
      
      AnyRefNode StartFrame = {
        sRel = {1.0,0.0,0};
      };
      AnyRefNode EndFrame = {
        sRel = {1.5,0.0,0};
      };


      AnyDrawRefFrame DrwGlobalRef = {ScaleXYZ = 0.3*{1,1,1};};    
    };
    
    // -----------------------------------------------------
    // Segments
    // -----------------------------------------------------   
    // Create two segments      
    
      AnySeg Seg1 = {
        r0 = {0.5,0.0,0.0};
        Mass = 20.0;
        Jii = {0.05,0.1,0.1};
        AnyRefNode Node0 ={};
        AnySurfCylinder Disc = 
        {
          //sRel = {0.0, 0.0, 0.0};
          ARel = RotMat(pi/2,y); //{{1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}, {0.0, 0.0, 1.0}};
          viewSurface = 
          {
          Visible = On;
          Opacity = 1.0;
          Pickable = On;
          PickableZOrdering = 0;
          RGB = {0.85, 0.05, 0.05};
          ScaleXYZ = {1.0, 1.0, 1.0};
          };
          Radius = 0.5;
          Length = 0.01;
          CapRatio = 0.01;
          CapRatio2 = 0.01;
          //CircularCap = Off;
          //CircularCap2 = Off;
        };
      }; // seg1

      AnySeg Seg2 = {
        r0 = {1.0,0.0,0.0};
        Mass = 0.0;
        Jii = {0.05,0.1,0.1};
        AnyRefNode Node0 ={};
        AnySurfCylinder Disc = 
        {
          sRel = {0.0, 0.0, 0.0};
          ARel = RotMat(pi/2,y); //{{1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}, {0.0, 0.0, 1.0}};
          viewSurface = 
          {
          Visible = On;
          Opacity = 1.0;
          Pickable = On;
          PickableZOrdering = 0;
          RGB = {0.05, 0.85, 0.05};
          ScaleXYZ = {1.0, 1.0, 1.0};
          };
          Radius = 0.1;
          Length = 0.1;
        };

//        AnyRefNode LoadNode = {sRel = {0.5,0.0,0};};        
//        AnyDrawSeg DrwSeg= { RGB = {0,1,0};Opacity = 0.2;};
      }; // seg2         

      
    // -----------------------------------------------------
    // Joints
    // -----------------------------------------------------
    
    AnyFolder Joints = {
      // Joint between Seg1 and Global ref
      AnyPrismaticJoint JntS1 = {
        AnyRefNode &Ground = Main.Model.GlobalRef.N1;
        AnySeg &Seg = Main.Model.Seg1;
        Axis = x;
        // Reaction forces between S1 and ground are enabled by default
      };
            
      AnyPrismaticJoint JntS2 = {
        AnyRefFrame &Ground = Main.Model.GlobalRef.StartFrame;
        AnySeg &Seg = Main.Model.Seg2;
        Axis = x;
        // Switch off reaction forces between S2 and ground
        Constraints.Reaction.Type = repmat(Constraints.nDim,On);
      };
            
    }; // Joints
    
    AnyFolder InitializationArgs = {
          AnyVar UserDefinedDistLimitLow = -0.01;
          AnyVar UserDefinedDistLimitHigh = 0.01;
          AnyVar UserDefinedRadiusLimit=0.02;
          AnyVar UserDefinedVelLimitHigh= 0.8;
          AnyVec3 UserDefinedGroundVel = {0.0,0.0,0};
//          AnyVar Strength = 500;
//          AnyVar StaticFrictionCoefficient = 0.5;
//          AnyVar ScaleFactor = 1;
        };

    AnyFolder KinMeasures = {
      
      CreateManySubTemplates Measures (
      NUM=1,
      T_NAME= "KinMsrClass",
      NAME_PREFIX="",
      ARG1=Main.Model.Seg2,
      ARG2=Main.Model.Seg1,
      ARG3=AnyKinLinear, 
      ARG4=..MeasuresOrg,
      ARG5="X"
      //        ARG_INI_SWITCH = 1,
      //        ARG_INI =..InitializationArgs
      )={
        
        AnyKinMeasureOrg MeasuresNormal = {};
        AnyKinMeasureOrg MeasuresFriction1 = {};
        AnyKinMeasureOrg MeasuresFriction2 = {};
      };
    };
    
    AnyFolder ContDetect = {
      CylContDetClass2 ContCheck (
      ARG1 =..KinMeasures.Measures,
      ARG_INI_SWITCH = 1,
      ARG_INI =..InitializationArgs) = {};
      
    };
    
    AnyFolder ContDetectSmooth = {
      ContactConditionSmoothing2 RadiusSmoothing (
      ARG1="FUNC_PROFILE_LINEAR",
      ARG2=..ContDetect.ContCheck.RadiusRatio,
      ARG3=1.0,
      ARG4=0.9) = {};
      
      ContactConditionSmoothing2 HeightSmoothing (
      ARG1="FUNC_PROFILE_LINEAR",
      ARG2=..ContDetect.ContCheck.HeightRatio,
      ARG3=1.0,
      ARG4=0.8) = {};
      
      //          ContactConditionSmoothing2 VelocitySmoothing (
      //          ARG1="FUNC_PROFILE_LINEAR",
      //          ARG2=..ContDetect.ContCheck.VelRatio,
      //          ARG3=1.0,
      //          ARG4=0.15) = {};
      
      //          AnyFloat SmoothingFun = mult(mult(RadiusSmoothing.SmoothingFun,HeightSmoothing.SmoothingFun),VelocitySmoothing.SmoothingFun);
      AnyFloat SmoothingFun = mult(RadiusSmoothing.SmoothingFun,HeightSmoothing.SmoothingFun);
    };
//    AnyMatrix M = {
//                      {0, .LowerLimitHard-1e1*LowPhaseIn-1e1*TotalRange},
//                      {80, .LowerLimitHard-1e1*LowPhaseIn},
//                      {160,  .LowerLimitHard},
//                      {490, .LowerLimit},
//                      {510, .HighLimit},
//                      {840, .HighLimitHard},
//                      {920, .HighLimitHard+1e1*HighPhaseIn},
//                      {999, .HighLimitHard+1e1*HighPhaseIn+1e1*TotalRange}                    
//                    }; 
    AnyFolder MeasuresAndDrivers = {
      
      // Function to generate a -1, +1 signal for producing absolute value
      AnyFunInterpol AbsoluteFun = {
        Type = PiecewiseLinear;
        T = {-100,-0.000001,0,0.000001,100};
        Data = {{-1,-1,0,1,1}};
      };
      
      // Generate a -1 signal if Meas is neg or +1 signal if Meas is positive
      AnyKinMeasureFunComb1 PosNegSignalS1StartFrame = {
        AnyKinMeasure &meas = ..KinMeasures.Measures.MeasuresNormal;
        Functions = {&.AbsoluteFun};
      };
      
      // Take absolute value of the measure. Multiply neg measure with -1 and vice versa
      AnyKinMeasureQuadComb AbsMeas_S1_S2 = {
        AnyKinMeasure &measFun = .PosNegSignalS1StartFrame;
        AnyKinMeasure &measNorm = .PosNegSignalS1StartFrame.meas;
        AnyFloat Check = measNorm.Pos[0]*measFun.Pos[0];
        OutDim = 1;
        // Product of two measures
        CoefQuadTensor = {{{0.0, 1.0}, {0.0, 0.0}}};
      };
      
      // Generate a rising edge when value reaches zero
      AnyFunInterpol ZeroOnFun = {
        Type = PiecewiseLinear;
        T = {-100,-0.0001,0,0.01,100};
        Data = {{1,1,1,0,0}};
      };
      
      // Generate a falling edge when value reaches zero
      AnyFunInterpol ZeroOffFun = {
        Type = PiecewiseLinear;
        T = {-100,-0.0001,0,0.01,100};
        Data = {{0,0,0,1,1}};
      };
      
      // Generate a rising edge signal when S1 reaches S2 (which is at start frame)
      AnyKinMeasureFunComb1 ActiveSignalS1StartFrame = {
        AnyKinMeasure &meas = .AbsMeas_S1_S2;
        Functions = {&.ZeroOnFun};
      };
      
      // Generate a falling edge signal when S1 reaches S2 (which is at start frame)
      AnyKinMeasureFunComb1 InactiveSignalS1StartFrame = {
        AnyKinMeasure &meas = .AbsMeas_S1_S2;
        Functions = {&.ZeroOffFun};
      };


      // Take product of rising edge when S1 is close to S2 and distance between S1 and S2.
      AnyKinMeasureQuadComb CombMeas2 = {
        AnyKinMeasure &measFun = .ActiveSignalS1StartFrame;
        AnyKinMeasure &measNorm = Main.Model.KinMeasures.Measures.MeasuresNormal;
        AnyFloat Check = measNorm.Pos[0]*measFun.Pos[0];
        OutDim = 1;
        CoefQuadTensor = {{{0.0, 1.0}, {0.0, 0.0}}};
      };
      
      // Generate end condition:
      AnyKinMeasureOrg Meas_S2_EndFrame = {
        AnyKinLinear Lin_S2_EndFrame = {
          AnyRefFrame &seg = ...Seg2;
          AnyRefFrame &refFrame = ...GlobalRef.EndFrame;
        };
        MeasureOrganizer = {0};
      };
      
      // Generate a -1 signal if Meas is neg or +1 signal if Meas is positive
      AnyKinMeasureFunComb1 PosNegSignalS2EndFrame = {
        AnyKinMeasure &meas = .Meas_S2_EndFrame;
        Functions = {&.AbsoluteFun};
      };
      
      // Take absolute value of the measure. Multiply neg measure with -1 and vice versa
      AnyKinMeasureQuadComb AbsMeas_S2_EndFrame = {
        AnyKinMeasure &measFun = .PosNegSignalS2EndFrame;
        AnyKinMeasure &measNorm = .PosNegSignalS2EndFrame.meas;
        AnyFloat Check = measNorm.Pos[0]*measFun.Pos[0];
        OutDim = 1;
        // Product of two measures
        CoefQuadTensor = {{{0.0, 1.0}, {0.0, 0.0}}};
      };
      
      // Generate a rising edge signal when S2 reaches end frame
      AnyKinMeasureFunComb1 ActiveSignalS2EndFrame = {
        AnyKinMeasure &meas = .AbsMeas_S2_EndFrame;
        Functions = {&.ZeroOnFun};
      };
    
      // Generate a rising edge signal when S2 reaches end frame
      AnyKinMeasureFunComb1 InactiveSignalS2EndFrame = {
        AnyKinMeasure &meas = .AbsMeas_S2_EndFrame;
        Functions = {&.ZeroOffFun};
      };
    
      // Take product of rising edge when S1 is close to S2 and distance between S1 and S2.
      AnyKinMeasureQuadComb CombMeas3 = {
        AnyKinMeasure &measFun = .InactiveSignalS2EndFrame;
        AnyKinMeasure &measNorm = .ActiveSignalS1StartFrame;
        AnyFloat Check = measNorm.Pos[0]*measFun.Pos[0];
        OutDim = 1;
        CoefQuadTensor = {{{0.0, 1.0}, {0.0, 0.0}}};
      };
    
      // Product of active signal with measure between S1 and S2.
      AnyKinMeasureQuadComb CombMeas4 = {
        AnyKinMeasure &measFun = .CombMeas3;
        AnyKinMeasure &measNorm = Main.Model.KinMeasures.Measures.MeasuresNormal;
        AnyFloat Check = measNorm.Pos[0]*measFun.Pos[0];
        OutDim = 1;
        CoefQuadTensor = {{{0.0, 1.0}, {0.0, 0.0}}};
      };
    
      AnyKinMeasureQuadComb MeasHoldS2Start = {
        AnyKinMeasure &measFun = .InactiveSignalS1StartFrame;
        AnyKinMeasure &measNorm = Main.Model.Joints.JntS2;
        //            AnyFloat Check = measNorm.Pos[0]*measFun.Pos[0];
        OutDim = 1;
        CoefQuadTensor = {{{0.0, 1.0}, {0.0, 0.0}}};
      };
    
      AnyKinMeasureQuadComb MeasHoldS2End = {
        AnyKinMeasure &measFun = .ActiveSignalS2EndFrame;
        AnyKinMeasure &measNorm = Main.Model.Joints.JntS2;
        //            AnyFloat Check = measNorm.Pos[0]*measFun.Pos[0];
        OutDim = 1;
        CoefQuadTensor = {{{0.0, 1.0}, {0.0, 0.0}}};
      };





      
      AnyFunInterpol interpol = {
        Type = PiecewiseLinear;
        T = {-100,-0.15,-0.1,-0.009,0,0.009,0.1,0.15,100};
        //            Data = {{0,0,0,1,1,1,0,0,0}};
        Data = {{0,0,0,0,0,1,1,1,1}};
      };
      AnyFunInterpol interpolInv = {
        Type = PiecewiseLinear;
        T = .interpol.T;
        Data = {{1,1,1,1,0,1,1,1,1}};
      };
      
      AnyFloat dd = interpol(Main.Model.KinMeasures.Measures.MeasuresNormal.Pos[0]);
      
      AnyKinMeasureFunComb1 measureFun = {
        AnyKinMeasure &normalmeasure = Main.Model.KinMeasures.Measures.MeasuresNormal;
        Functions = {&.interpol};
      };
      AnyKinMeasureFunComb1 measureFunInv = {
        AnyKinMeasure &normalmeasure = Main.Model.KinMeasures.Measures.MeasuresNormal;
        Functions = {&.interpolInv};
      };
      
      
      AnyKinMeasureQuadComb CombMeas = {
        AnyKinMeasure &measFun = .measureFun;
        AnyKinMeasure &measNorm = Main.Model.KinMeasures.Measures.MeasuresNormal;
        AnyFloat Check = measNorm.Pos[0]*measFun.Pos[0];
        OutDim = 1;
        CoefQuadTensor = {{{0.0, 1.0}, {0.0, 0.0}}};
      };
      
      AnyKinMeasureQuadComb CombMeasInv = {
        AnyKinMeasure &measFun = .measureFunInv;
        AnyKinMeasure &measNorm = Main.Model.KinMeasures.Measures.MeasuresNormal;
        AnyFloat Check = measNorm.Pos[0]*measFun.Pos[0];
        OutDim = 1;
        CoefQuadTensor = {{{0.0, 1.0}, {0.0, 0.0}}};
      };
      
      AnyKinMeasureQuadComb HoldS2Meas = {
        AnyKinMeasure &measFun = .measureFunInv;
        AnyKinMeasure &HoldS2 = Main.Model.Joints.JntS2;
        //            AnyFloat Check = measNorm.Pos[0]*measFun.Pos[0];
        OutDim = 1;
        CoefQuadTensor = {{{0.0, 1.0}, {0.0, 0.0}}};
      };
      
      
      AnyKinEqSimpleDriver DriverS1 = {
        AnyJoint &Jnt = ..Joints.JntS1;
        DriverPos = {0};
        DriverVel = 2*{0.2};
        DriverAcc = 0.9*{-0.1};
        Reaction.Type = {On};
      };
      
//      AnyKinEqSimpleDriver DefaultFixS2 = {
//        AnyJoint &Jnt = ..Joints.JntS2;
//        DriverPos = {0};
//        DriverVel = {0.000};
//        Reaction.Type = {On};
//        CType = {Soft};
//        WeightFun = {&DrvWeight};
//        AnyFunConst DrvWeight  ={
//          Value = {0.001};
//        };
//      };

      
      
      AnyKinEqSimpleDriver Drv = {
        //            AnyKinMeasure &meas = .measureFun;
        AnyKinMeasure &combMeas = .CombMeas4;
//        AnyKinMeasure &combMeas = .ActiveSignalS1StartFrame;
        DriverPos = {0.0};
        DriverVel = {0.0};
        CType = {Soft};
        WeightFun = {&DrvWeight};
        AnyFunConst DrvWeight  ={
          Value = {0.05};
        };          
        Reaction.Type = {Off};
      };
      
      AnyKinEqSimpleDriver DrvS2 = {
        //            AnyKinMeasure &meas = .measureFun;
        AnyKinMeasure &combMeas = .HoldS2Meas;
        DriverPos = {0.0};
        DriverVel = {0.0};
        CType = {Soft};
        WeightFun = {&DrvWeight};
        AnyFunConst DrvWeight  ={
          Value = {0.05};
        };          
        Reaction.Type = {Off};
      };
//      
//      AnyKinEqSimpleDriver DrvHoldS2Start = {
//        //            AnyKinMeasure &meas = .measureFun;
//        AnyKinMeasure &combMeas = .MeasHoldS2Start;
//        DriverPos = {0.0};
//        DriverVel = {0.0};
//        CType = {Soft};
//        WeightFun = {&DrvWeight};
//        AnyFunConst DrvWeight  ={
//          Value = {0.5};
//        };          
//        Reaction.Type = {Off};
//      };
//
//AnyKinEqSimpleDriver DrvHoldS2End = {
//        //            AnyKinMeasure &meas = .measureFun;
//        AnyKinMeasure &combMeas = .MeasHoldS2End;
//        DriverPos = {0.0};
//        DriverVel = {0.0};
//        CType = {Soft};
//        WeightFun = {&DrvWeight};
//        AnyFunConst DrvWeight  ={
//          Value = {0.5};
//        };          
//        Reaction.Type = {Off};
//      };

      
      
      
    }; // Measures and drivers
    
        
    
  }; // Model
  
  AnyBodyStudy Study = {
    AnyFolder& Model = Main.Model;
    Gravity = {0,-9.81,0};    
    nStep = 200;
    tEnd= 10;
    Kinematics.SolverType = KinSolOverDeterminate;
  };
  
  // Switch to define an automatic save of results to the Output folder
  #ifndef AutoSaveOption 
  #define AutoSaveOption 0
  #endif
  
  /**Execute this operation to run the model in the intended operation sequence.  
  It is also possible to run operations seperately, by manual selections in the operation tree*/
  AnyOperationSequence RunApplication = {
    
    ///This operation is the inverse dynamic analysis
    AnyOperation &InvAnal=Main.Study.InverseDynamics;
    
    #if AutoSaveOption 
    /// This operation saves the output of the study to an h5 file in the Output folder
    AnyOperationMacro save = {
      MacroStr={ "classoperation Main.Study.Output " + strquote("Save data") + " --type=Deep" + " --file="+ strquote(ANYBODY_PATH_OUTPUT + ANYBODY_NAME_MAINFILE + ".anydata.h5")};
    };
    #endif
  };  
  

  
};
