#include "../../../../libdef.any"
//////#include "EllipticCylinderPointsGrid.any"
//////#include "Split/FMM2.any"
//////#include "Split/DrawResultant.any"
//////
#include "Split/KinMsrClass.any"
////////#include "Split/CylContDetClass.any"
#include "Split/CylContDetClass2.any"
////////#include "Split/ContactConditionSmoothingClass.any"
#include "Split/ContactConditionSmoothingClass2.any"
////////#include "Split/CreateContactElementClass.any"
////////#include "Split/CreateContactElementClass2.any"
//////#include "Split/CreateContactElementClass3.any"
#include "Split/RepeaterCT.any"


//#include "ConditionalContactMultiPoints.any"
//#include "ConditionalContactDistanceAndVelocityDepClass.any"

/**
This model demonstrates a simple application of the class template
ConditionalContactMultiPoints. This class creates conditional
contact elements between nodes on the base object (base nodes) and 
nodes on the target object (target nodes). The contact elements are
created indvidually between corresponding nodes on the two objects.
That is, between <BaseObject>.Node0 and <TargetObject>.Node0, then 
between <BaseObject>.Node1 and <TargetObject>.Node1, and so on. 
This allows each node to have a unique orientation that can be used 
to define the normal and frictional directions for the contact 
elements. 

The model consists of two segments. The first segment is grounded
to the global ref using AnyStdJnt that simulates the reaction forces
between the ground and the first segment. The second segment is 
defined to be in contact with the first segment. The contact nodes
are generated using the EllipticCylinderPointsGrid class template, 
which allows parametrization of the contact points.

The model consists of different forces applied to the second segment
to visualize the force generated by the contact elements and the 
resultant force. There are two rotating force in the YZ and XZ plane. 
There is a constant force acting in -Y direction. Lastly, there is 
the gravitational force that will consider the weight of the second
segment. 

The conditional contact class will consider all the forces acting 
on the second segment.
*/
Main = {
  // Create folder with Draw Settings. These valuese are used by
  // the ConditionalContactMultiPoints class. This folder is 
  // generated normally whenever a human model is present in the
  // model.
  Template_DrawSettings DrawSettings = {}; 
  AnyFolder Model = {
    // -----------------------------------------------------
    // Basic Reference Frames (Global Ref)
    // -----------------------------------------------------
    AnyFixedRefFrame GlobalRef = {
      AnyRefNode N1 = {
        sRel = {0.5,0.0,0};
      };
      AnyRefNode N2 = {
        sRel = {1.0,0.0,0};
      };

      AnyDrawRefFrame DrwGlobalRef = {ScaleXYZ = 0.3*{1,1,1};};    
    };
    
    // -----------------------------------------------------
    // Segments
    // -----------------------------------------------------   
    // Create two segments      
    
      AnySeg Seg1 = {
        r0 = {0.5,0.0,0.0};
        Mass = 20.0;
        Jii = {0.05,0.1,0.1};
        AnyRefNode Node0 ={};
        AnySurfCylinder Disc = 
        {
          //sRel = {0.0, 0.0, 0.0};
          ARel = RotMat(pi/2,y); //{{1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}, {0.0, 0.0, 1.0}};
          viewSurface = 
          {
          Visible = On;
          Opacity = 1.0;
          Pickable = On;
          PickableZOrdering = 0;
          RGB = {0.85, 0.05, 0.05};
          ScaleXYZ = {1.0, 1.0, 1.0};
          };
          Radius = 0.5;
          Length = 0.01;
          //CapRatio = 0.1;
          //CapRatio2 = 0.1;
          //CircularCap = Off;
          //CircularCap2 = Off;
        };
      }; // seg1

      AnySeg Seg2 = {
        r0 = {1.0,0.0,0.0};
        Mass = 0.0;
        Jii = {0.05,0.1,0.1};
        AnyRefNode Node0 ={};
        AnySurfCylinder Disc = 
        {
          sRel = {0.0, 0.0, 0.0};
          ARel = RotMat(pi/2,y); //{{1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}, {0.0, 0.0, 1.0}};
          viewSurface = 
          {
          Visible = On;
          Opacity = 1.0;
          Pickable = On;
          PickableZOrdering = 0;
          RGB = {0.05, 0.85, 0.05};
          ScaleXYZ = {1.0, 1.0, 1.0};
          };
          Radius = 0.1;
          Length = 0.1;
          //CapRatio = 0.1;
          //CapRatio2 = 0.1;
          //CircularCap = Off;
          //CircularCap2 = Off;
        };

//        AnyRefNode LoadNode = {sRel = {0.5,0.0,0};};        
//        AnyDrawSeg DrwSeg= { RGB = {0,1,0};Opacity = 0.2;};
      }; // seg2         

      
    // -----------------------------------------------------
    // Joints
    // -----------------------------------------------------
    
    AnyFolder Joints = {
      // Joint between Seg1 and Global ref
      AnyPrismaticJoint JntS1 = {
        AnyRefNode &Ground = Main.Model.GlobalRef.N1;
        AnySeg &Seg = Main.Model.Seg1;
        Axis = x;
        // Reaction forces between S1 and ground are enabled by default
      };
      
      AnyKinEqSimpleDriver TranslationS1 = {
        AnyJoint &Jnt = .JntS1;
        DriverPos = {0};
        DriverVel = 2*{0.2};
        DriverAcc = 0.9*{-0.1};
        Reaction.Type = {On};
      };
      
      AnyPrismaticJoint JntS2 = {
        AnyRefFrame &Ground = Main.Model.GlobalRef.N2;
        AnySeg &Seg = Main.Model.Seg2;
        Axis = x;
        // Switch off reaction forces between S2 and ground
        Constraints.Reaction.Type = repmat(Constraints.nDim,On);
      };
      
//      AnyKinEqSimpleDriver TranslationS2 = {
//        AnyJoint &Jnt = .JntS2;
//        DriverPos = {0};
//        DriverVel = {0.000};
//        Reaction.Type = {On};
//        CType = {Soft};
//        WeightFun = {&DrvWeight};
//        AnyFunConst DrvWeight  ={
//          Value = {0.001};
//        };
//      };
      
    }; // Joints
    
    AnyFolder InitializationArgs = {
          AnyVar UserDefinedDistLimitLow = -0.01;
          AnyVar UserDefinedDistLimitHigh = 0.01;
          AnyVar UserDefinedRadiusLimit=0.02;
          AnyVar UserDefinedVelLimitHigh= 0.8;
          AnyVec3 UserDefinedGroundVel = {0.0,0.0,0};
//          AnyVar Strength = 500;
//          AnyVar StaticFrictionCoefficient = 0.5;
//          AnyVar ScaleFactor = 1;
        };

    AnyFolder KinMeasures = {
      
      CreateManySubTemplates Measures (
      NUM=1,
      T_NAME= "KinMsrClass",
      NAME_PREFIX="",
      ARG1=Main.Model.Seg2,
      ARG2=Main.Model.Seg1,
      ARG3=AnyKinLinear, 
      ARG4=..MeasuresOrg,
      ARG5="X"
      //        ARG_INI_SWITCH = 1,
      //        ARG_INI =..InitializationArgs
      )={
        
        AnyKinMeasureOrg MeasuresNormal = {};
        AnyKinMeasureOrg MeasuresFriction1 = {};
        AnyKinMeasureOrg MeasuresFriction2 = {};
      };
    };
    
     AnyFolder ContDetect = {
          CylContDetClass2 ContCheck (
          ARG1 =..KinMeasures.Measures,
          ARG_INI_SWITCH = 1,
          ARG_INI =..InitializationArgs) = {};
          
        };
        
        AnyFolder ContDetectSmooth = {
          ContactConditionSmoothing2 RadiusSmoothing (
          ARG1="FUNC_PROFILE_LINEAR",
          ARG2=..ContDetect.ContCheck.RadiusRatio,
          ARG3=1.0,
          ARG4=0.9) = {};
          
          ContactConditionSmoothing2 HeightSmoothing (
          ARG1="FUNC_PROFILE_LINEAR",
          ARG2=..ContDetect.ContCheck.HeightRatio,
          ARG3=1.0,
          ARG4=0.8) = {};
          
          //          ContactConditionSmoothing2 VelocitySmoothing (
          //          ARG1="FUNC_PROFILE_LINEAR",
          //          ARG2=..ContDetect.ContCheck.VelRatio,
          //          ARG3=1.0,
          //          ARG4=0.15) = {};
          
          //          AnyFloat SmoothingFun = mult(mult(RadiusSmoothing.SmoothingFun,HeightSmoothing.SmoothingFun),VelocitySmoothing.SmoothingFun);
          AnyFloat SmoothingFun = mult(RadiusSmoothing.SmoothingFun,HeightSmoothing.SmoothingFun);
          
          AnyFunInterpol interpol = {
            Type = PiecewiseLinear;
            T = {-100,-0.15,-0.1,-0.09,0,0.09,0.1,0.15,100};
//            Data = {{0,0,0,1,1,1,0,0,0}};
            Data = {{0,0,0,0,0,1,1,1,1}};
          };
          AnyFunInterpol interpolInv = {
            Type = PiecewiseLinear;
            T = .interpol.T;
            Data = {{1,1,1,1,0,1,1,1,1}};
          };

          AnyFloat dd = interpol(Main.Model.KinMeasures.Measures.MeasuresNormal.Pos[0]);
          
          AnyKinMeasureFunComb1 measureFun = {
            AnyKinMeasure &normalmeasure = Main.Model.KinMeasures.Measures.MeasuresNormal;
            Functions = {&.interpol};
          };
          AnyKinMeasureFunComb1 measureFunInv = {
            AnyKinMeasure &normalmeasure = Main.Model.KinMeasures.Measures.MeasuresNormal;
            Functions = {&.interpolInv};
          };

          
          AnyKinMeasureQuadComb CombMeas = {
            AnyKinMeasure &measFun = .measureFun;
            AnyKinMeasure &measNorm = Main.Model.KinMeasures.Measures.MeasuresNormal;
            AnyFloat Check = measNorm.Pos[0]*measFun.Pos[0];
            OutDim = 1;
            CoefQuadTensor = {{{0.0, 1.0}, {0.0, 0.0}}};
          };
          
          AnyKinMeasureQuadComb CombMeasInv = {
            AnyKinMeasure &measFun = .measureFunInv;
            AnyKinMeasure &measNorm = Main.Model.KinMeasures.Measures.MeasuresNormal;
            AnyFloat Check = measNorm.Pos[0]*measFun.Pos[0];
            OutDim = 1;
            CoefQuadTensor = {{{0.0, 1.0}, {0.0, 0.0}}};
          };
          
          AnyKinMeasureQuadComb HoldS2Meas = {
            AnyKinMeasure &measFun = .measureFunInv;
            AnyKinMeasure &HoldS2 = Main.Model.Joints.JntS2;
//            AnyFloat Check = measNorm.Pos[0]*measFun.Pos[0];
            OutDim = 1;
            CoefQuadTensor = {{{0.0, 1.0}, {0.0, 0.0}}};
          };


          AnyKinEqSimpleDriver Drv = {
//            AnyKinMeasure &meas = .measureFun;
            AnyKinMeasure &combMeas = .CombMeas;
            DriverPos = {0.0};
            DriverVel = {0.0};
            CType = {Soft};
            WeightFun = {&DrvWeight};
            AnyFunConst DrvWeight  ={
              Value = {0.05};
            };          
            Reaction.Type = {Off};
          };
        
        AnyKinEqSimpleDriver DrvS2 = {
//            AnyKinMeasure &meas = .measureFun;
            AnyKinMeasure &combMeas = .HoldS2Meas;
            DriverPos = {0.0};
            DriverVel = {0.0};
            CType = {Soft};
            WeightFun = {&DrvWeight};
            AnyFunConst DrvWeight  ={
              Value = {0.05};
            };          
            Reaction.Type = {Off};
          };

        
        
        };
        
        
    
  }; // Model
  
  AnyBodyStudy Study = {
    AnyFolder& Model = Main.Model;
    Gravity = {0,-9.81,0};    
    nStep = 100;
    tEnd= 10;
    Kinematics.SolverType = KinSolOverDeterminate;
  };
  
  // Switch to define an automatic save of results to the Output folder
  #ifndef AutoSaveOption 
  #define AutoSaveOption 0
  #endif
  
  /**Execute this operation to run the model in the intended operation sequence.  
  It is also possible to run operations seperately, by manual selections in the operation tree*/
  AnyOperationSequence RunApplication = {
    
    ///This operation is the inverse dynamic analysis
    AnyOperation &InvAnal=Main.Study.InverseDynamics;
    
    #if AutoSaveOption 
    /// This operation saves the output of the study to an h5 file in the Output folder
    AnyOperationMacro save = {
      MacroStr={ "classoperation Main.Study.Output " + strquote("Save data") + " --type=Deep" + " --file="+ strquote(ANYBODY_PATH_OUTPUT + ANYBODY_NAME_MAINFILE + ".anydata.h5")};
    };
    #endif
  };  
  

  
};
