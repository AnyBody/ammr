/* Class Template RectangularPointsGrid

This class template creates a uniformly distributed grid of 
reference nodes in a rectangular grid. One axis of the 
generated nodes is oriented to be normal to the circumference 
of the ellipse while one axis is parallel to the axis of the 
cylinder. The class template requires an AnyRefFrame object 
and grid parameters (defined below). It calculates the relative 
positions and orientations of the reference nodes and uses 
AnyRefNodeGroup to generate the nodes.

Class arguments:
---------------
CENTER_FRAME: <Obligatory>
Is an AnyRefFrame object that is the central frame for the 
elliptical cylinder. This is the reference frame used by 
AnyRefNodeGroup to generate the node group.

AXIS: <Optional. Default = "Z">
Is the axis of the cylinder

LENGTH: <Obligatory>
Is the length of the cylinder. AnyFloat > 0.0

MAJ_AX: <Obligatory>
Is the major axis of the ellipse. AnyFloat > 0.0

MIN_AX: <Obligatory>
Is the minor axis of the ellipse. AnyFloat > 0.0

nSteps_S1: <Obligatory>
Number of rows in the grid. AnyInt > 0

nSteps_S2: <Obligatory>
Number of columns in the grid. AnyInt > 0

NAME: <Optional. Default = NodeGroup>
Name for the instance of the AnyRefNodeGroup class to generate 
the reference nodes.

Optional initialization:
-----------------------
Settings:
    StartAngle	: Angular offset for the first column.
    EndAngle		: Angular offset for the last column.
    NodesName		: Name of the nodes generated by AnyRefNodeGroup. 
                      The nodes are named as NodesName0, NodesName1, 
                      NodesName3, etc.
    srel		: Relative position vector of the node group from 
                      CENTER_FRAME.
    arel		: Relative rotational transformation matrix of the 
                      node group from CENTER_FRAME

Please note:
------------
* EndAngle must be greater than StartAngle.
* If nSteps_S2 is 1, EndAngle - Start Angle must be equal to 2*pi. The 
  single column will be generated at StartAngle
* Uniform distribution on the ellipse requires the assumption 
  that minor axis is less than or equal to the major axis. If 
  minor axis is greater than major axis, the distribution of 
  the nodes may not be uniform.

Initialization example:
----------------------
EllipticCylinderPointsGrid <Object_name> (
      CENTER_FRAME = <AnyRefFrame>,
      AXIS = "<X|Y|*Z>",
      LENGTH = 0.2,
      MAJ_AX = 0.12,
      MIN_AX = 0.06,
      nSteps_S1 = 5,
      nSteps_S2 = 4,
      NAME = NodeGroup) = {
      // Optional initialization showing default values
        Settings = {
          StartAngle = 0*pi;
          EndAngle = 2*pi;
          NodesName = "Node";
          srel = {0,0,0};
          arel = {{1,0,0},{0,1,0},{0,0,1}};
        };
      };

*/


#class_template RectangularPointsGrid (
CENTER_FRAME,
NORMAL = "Z",
NAME = NodeGroup
)
{
  #var AnyVar Side1; // in m
  #var AnyVar Side2; // in m
  #var AnyInt nSteps_S1; 
  #var AnyInt nSteps_S2;
  AnyRefFrame &CenterFrame = CENTER_FRAME;
  AnyFolder Settings = {
////    AnyFloat Length = LENGTH; // in m
////    AnyFloat Maj_ax = MAJ_AX; // in m
////    AnyFloat Min_ax = MIN_AX; // in m (Min_ax <= Maj_ax)
////    AnyInt nSteps_S1 = nSteps_S1;
////    AnyInt nSteps_S2 = nSteps_S2; // if nSteps_S2 = 1, ensure EndAngle-StartAngle = 2*pi
////    #var AnyVar StartAngle = 0; // in radians
////    #var AnyVar EndAngle = 2*pi; // in radians
    #var AnyStringVar NodesName = "Node"; // 
    #var AnyFloat NodesOrientation = {{1,0,0},{0,1,0},{0,0,1}};
    #var AnyFloat NodesLinOffset = {0,0,0};
    #var AnyFloat NodesRotOffset = {{1,0,0},{0,1,0},{0,0,1}};
  };
  
  AnyFolder Calculation = {
////    AnyInt WARNING_AXES = warn(gteqfun(.Settings.Maj_ax,.Settings.Min_ax),"Major axis is less than minor axis. Point distribution may not be uniform.");
////    
////    AnyInt CondCheck = ltfun(.Settings.StartAngle,.Settings.EndAngle);
////    AnyInt ERROR_ANGLES = assert(ltfun(.Settings.StartAngle,.Settings.EndAngle),"Please ensure EndAngle is greater than StartAngle") ;
//
////    #if nSteps_S2 == 1
////    AnyInt nSteps_S2_is_1 = expect(ltfun(abs(.Settings.EndAngle-.Settings.StartAngle-2*pi),1e-5),\
////                                "When nSteps_S2 = 1, please ensure EndAngle-StartAngle = 2*pi. The single column will be defined at StartAngle");
////    #endif

    AnyFloat stepS1 = .Side1/.nSteps_S1; // step along Side1
    AnyFloat startS1 = 0.0 - (.Side1/2);
    AnyFloat endS1 = 0.0 + (.Side1/2);
    
    // Array for height of each row
    // D2Arr = (if nSteps_S1 = 1, True: same as parent, False: linspace)
    // linspace returns nan with nrow =1      
    AnyFloat D1Arr = iffun(eqfun(.nSteps_S1,1), 0.0,\
                        linspace(startS1,endS1,.nSteps_S1)); // S1 array
                        
    AnyFloat stepS2 = .Side2/.nSteps_S2; // step along Side1
    AnyFloat startS2 = 0.0 - (.Side2/2);
    AnyFloat endS2 = 0.0 + (.Side2/2);
    
    // Array for height of each row
    // D2Arr = (if nSteps_S1 = 1, True: same as parent, False: linspace)
    // linspace returns nan with nrow =1      
    AnyFloat D2Arr = iffun(eqfun(.nSteps_S2,1), 0.0,\
                        linspace(startS2,endS2,.nSteps_S2)); // S1 array
                    
    
////    // Array for the rotational angle of each column
////    // Avec = (if total angle = 2pi, True: farr, False: linspace)
////    // in case full loop is desired, farr needs to be used.
////    // With linspace, first and last vertical column will overlap in full loop.
////    AnyFloat Avec = iffun(ltfun(abs(.Settings.EndAngle-.Settings.StartAngle-2*pi),1e-5),\
////                        farr(.Settings.StartAngle,(.Settings.EndAngle-.Settings.StartAngle)/.Settings.nSteps_S2, .Settings.nSteps_S2) + 0*ERROR_ANGLES,\
////                        linspace(.Settings.StartAngle,.Settings.EndAngle,.Settings.nSteps_S2));
////    
////    /*
////    Array for defining t_angle. In case of ellipse, uniformly
////    distributed Avec will result in non-equidistant points on 
////    the ellipse. t_angle is a function of Avec, maj_ax, and 
////    min_ax to generate equidistant points on the ellipse. The
////    function requires the assumption that min_ax <= maj_ax. 
////    Otherwise, point distribution may not be uniform on the
////    ellipse. For more info, see:
////    https://math.stackexchange.com/questions/2093569/points-on-an-ellipse
////    */    
////    AnyFloat esq = 1 - (.Settings.Min_ax/.Settings.Maj_ax)^2;
////    AnyFloat esqT1 = (esq/8 + (esq^2)/16 + (esq^3)*71/2048);
////    AnyFloat esqT2 = ((esq^2)*5/256 + (esq^3)*5/256); 
////    AnyFloat esqT3 = ((esq^3)*29/6144);
////    AnyFloat tvec = Avec + esqT1*sin(2*Avec) + esqT2*sin(4*Avec) + esqT3*sin(6*Avec);
////    
////    // D0 and D1 coordinates using the t_angle of each column.
////    AnyFloat D0Arr = .Settings.Maj_ax*cos(tvec); // D0 array
////    AnyFloat D1Arr = .Settings.Min_ax*sin(tvec); // D1 array
////    
////    // Normal angles at the points in the ellipse
////    AnyFloat Nvec = atan(D1Arr/D0Arr*(.Settings.Maj_ax/.Settings.Min_ax)^2);
////    // Correct for + pi when D0Arr >= 0
////    AnyFloat N2vec = iffun(ltfun(D0Arr,0),Nvec,Nvec+pi);
    
    // repeat D1 coordinates ncol times
    AnyFloat repD1 = repmat(.nSteps_S2,D1Arr);
////    AnyFloat repD2 = repmat(.nSteps_S1,D1Arr);
    // repeat D2 coordinates nrow times and sort
    AnyFloat repD2_unsorted = repmat(.nSteps_S1,D2Arr); // repeat height vector ncol times
    AnyFloat repD2 = ObjSort(repD2_unsorted); // sort height vector in ascending order
    AnyFloat repD0 = repmat(.nSteps_S1*.nSteps_S2,0.0);

    AnyFloat repARels = repmat(.nSteps_S1*.nSteps_S2,{.Settings.NodesOrientation});
    
    // repeat angle vector by nrow times for orientation of all points
////    AnyFloat RotAngle = repmat(.Settings.nSteps_S1, N2vec); 
    
    // position coordinates and ARels of nRow*nCol points
    #if NORMAL == "Z"
    AnyMatrix Positions = {repD1,repD2,repD0}';
    AnyRefFrameAxis Normal = z;
////    AnyFloat ARel_0 = {cos(RotAngle),sin(RotAngle),repmat(SizesOf(RotAngle)[0],{0.0})}';
////    AnyFloat ARel_1 = {-sin(RotAngle),cos(RotAngle),repmat(SizesOf(RotAngle)[0],{0.0})}';
////    AnyFloat ARel_2 = repmat(SizesOf(RotAngle)[0],{{0,0,1}});
////    AnyFloat ARel_Mat = {ARel_0',ARel_1',ARel_2'};
////    AnyFloat ARel_transpose = transpose(ARel_Mat);
    #endif
    
    #if NORMAL == "Y"
    AnyMatrix Positions = {repD2,repD0,repD1}';
    AnyRefFrameAxis Normal = y;
////    AnyFloat ARel_0 = {cos(RotAngle),repmat(SizesOf(RotAngle)[0],{0.0}),-sin(RotAngle)}';
////    AnyFloat ARel_1 = repmat(SizesOf(RotAngle)[0],{{0,1,0}});
////    AnyFloat ARel_2 = {sin(RotAngle),repmat(SizesOf(RotAngle)[0],{0.0}),cos(RotAngle)}';
////    AnyFloat ARel_Mat = {ARel_0',ARel_1',ARel_2'};
////    AnyFloat ARel_transpose = transpose(ARel_Mat);
    #endif
    
    #if NORMAL == "X"
    AnyMatrix Positions = {repD0,repD1,repD2}';
    AnyRefFrameAxis Normal = x;
////    AnyFloat ARel_0 = repmat(SizesOf(RotAngle)[0],{{1,0,0}});
////    AnyFloat ARel_1 = {repmat(SizesOf(RotAngle)[0],{0.0}),cos(RotAngle),sin(RotAngle)}';
////    AnyFloat ARel_2 = {repmat(SizesOf(RotAngle)[0],{0.0}),-sin(RotAngle),cos(RotAngle)}';
////    AnyFloat ARel_Mat = {ARel_0',ARel_1',ARel_2'};
////    AnyFloat ARel_transpose = transpose(ARel_Mat);
    #endif
  };    
  
  AnyFloat Nodes_sRels = Calculation.Positions;
  AnyFloat Nodes_ARels = Calculation.repARels;
  AnyRefFrameAxis Nodes_Normal = Calculation.Normal;

  CenterFrame = {
            
    AnyRefNodeGroup NAME = {
      NodeAmount = ..nSteps_S1*..nSteps_S2;
      sRel = ..Settings.NodesLinOffset;
      ARel = ..Settings.NodesRotOffset;
      Node_sRels = ..Nodes_sRels;
      Node_ARels = ..Nodes_ARels;
//      viewRefFrame.Visible = On;
      NodeName = ..Settings.NodesName;
      NodeDefaults.CreateMotionOutput = {
        r = On;
        Axes = On;
      };

    };
      
        
  };
  
};


