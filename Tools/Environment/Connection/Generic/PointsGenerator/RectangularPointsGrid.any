/* Class Template RectangularPointsGrid

This class template creates a uniformly distributed grid of 
reference nodes in a rectangular grid. The class template 
requires an AnyRefFrame object, normal to the rectangle plane,
and the grid parameters to generate the reference nodes in the
rectangular grid. The grid is centered on the AnyRefFrame 
object and, by default, the axes of the generated reference 
nodes have the same orientation as the input AnyRefFrame 
object.

Class arguments:
---------------
CENTER_FRAME: <Obligatory>
Is an AnyRefFrame object that is the central frame for the 
rectangular grid. This is the reference frame used by 
AnyRefNodeGroup to generate the node group.

NORMAL: <Optional. Default = "Z">
Is the normal to the plane in which the rectangular grid will
be generated.

NAME: <Optional. Default = NodeGroup>
Name for the instance of the AnyRefNodeGroup class to generate 
the reference nodes.

Obligatory initialization:
-----------------------
Side1: <Obligatory>
Is the length of the rectangle along the first 
axis after the NORMAL in the sequence X, Y, Z.
AnyFloat > 0.0

Side2: <Obligatory>
Is the length of the rectangle along the second 
axis after the NORMAL in the sequence X, Y, Z.
AnyFloat > 0.0

nPoints_S1: <Obligatory>
Number of points in the grid along Side1. AnyInt > 0

nPoints_S2: <Obligatory>
Number of points in the grid along Side2. AnyInt > 0

Optional initialization:
-----------------------
Settings:
    NodesName		: Name of the nodes generated by AnyRefNodeGroup. 
                      The nodes are named as NodesName0, NodesName1, 
                      NodesName3, etc.
    NodesOrientation: Rotational transformation matrix providing the orientation
                      individual reference nodes relative to CENTER_FRAME.
    NodesLinOffset	: Relative position offset of the node group from 
                      CENTER_FRAME.
    NodesRotOffset	: Rotational transformation matrix providing the relative
                      rotational offset of the node group from CENTER_FRAME

Initialization example:
----------------------
RectangularPointsGrid <Object_name> (
      CENTER_FRAME = <AnyRefFrame>,
      NORMAL = "<X|Y|*Z>",
      NAME = NodeGroup) = {
        Side1 = 0.5;
        Side2 = 0.2;
        nPoints_S1 = 4;
        nPoints_S2 = 6;
        // Optional initialization showing default values
        Settings = {
          NodesName = "Node";
          NodesOrientation = {{1,0,0},{0,1,0},{0,0,1}};
          NodesLinOffset = {0,0,0};
          NodesRotOffset = {{1,0,0},{0,1,0},{0,0,1}};
        };
      };

*/


#class_template RectangularPointsGrid (
CENTER_FRAME,
NORMAL = "Z",
NAME = NodeGroup
)
{
  #var AnyVar Side1; // in m
  #var AnyVar Side2; // in m
  #var AnyInt nPoints_S1; 
  #var AnyInt nPoints_S2;
  AnyRefFrame &CenterFrame = CENTER_FRAME;
  AnyFolder Settings = {
    #var AnyStringVar NodesName = "Node"; // 
    #var AnyFloat NodesOrientation = {{1,0,0},{0,1,0},{0,0,1}};
    #var AnyFloat NodesLinOffset = {0,0,0};
    #var AnyFloat NodesRotOffset = {{1,0,0},{0,1,0},{0,0,1}};
  };
  
  AnyFolder Calculation = {

    AnyFloat stepS1 = .Side1/.nPoints_S1; // step size along Side1
    AnyFloat startS1 = 0.0 - (.Side1/2);
    AnyFloat endS1 = 0.0 + (.Side1/2);
    
    // Array for distance between nPoints along Side1
    // D1Arr = (if nPoints_S1 = 1, True: same as parent, False: linspace)
    // linspace returns nan with nrow =1      
    AnyFloat D1Arr = iffun(eqfun(.nPoints_S1,1), 0.0,\
                        linspace(startS1,endS1,.nPoints_S1)); // S1 array
                        
    AnyFloat stepS2 = .Side2/.nPoints_S2; // step along Side1
    AnyFloat startS2 = 0.0 - (.Side2/2);
    AnyFloat endS2 = 0.0 + (.Side2/2);
    
    // Array for distance between nPoints along Side1
    // D2Arr = (if nPoints_S2 = 1, True: same as parent, False: linspace)
    // linspace returns nan with nrow =1      
    AnyFloat D2Arr = iffun(eqfun(.nPoints_S2,1), 0.0,\
                        linspace(startS2,endS2,.nPoints_S2)); // S2 array
                        
    // repeat D1 coordinates nPoints_S2 times
    AnyFloat repD1 = repmat(.nPoints_S2,D1Arr);
    // repeat D2 coordinates nPoints_S1 times and sort
    AnyFloat repD2_unsorted = repmat(.nPoints_S1,D2Arr); // repeat D2 vector nPoints_S1 times
    AnyFloat repD2 = ObjSort(repD2_unsorted); // sort D2 vector in ascending order
    // D0 vector, i.e., along normal direction, is 0.0
    AnyFloat repD0 = repmat(.nPoints_S1*.nPoints_S2,0.0); // generate D0 vector for the total number of points
    // repeate Angular orientation transformation matrix for total number of points
    AnyFloat repARels = repmat(.nPoints_S1*.nPoints_S2,{.Settings.NodesOrientation});
    
    // position coordinates of nPoints_S1*nPoints_S2 points
    #if NORMAL == "Z"
    //if nPoints_S1 == 1 and nPoints_S2 == 1
    //TRUE: {{0.0,0.0,0.0}}
    //FALSE: {assemble arrays to form position matrix}
    AnyMatrix Positions = iffun(andfun(eqfun(.nPoints_S1,1),eqfun(.nPoints_S2,1)),\
                                {{repD1,repD2,repD0}'},\
                                 {repD1,repD2,repD0}');
    AnyRefFrameAxis Normal = z;
    #endif
    
    #if NORMAL == "Y"
    //if nPoints_S1 == 1 and nPoints_S2 == 1
    //TRUE: {{0.0,0.0,0.0}}
    //FALSE: {assemble arrays to form position matrix}
    AnyMatrix Positions = iffun(andfun(eqfun(.nPoints_S1,1),eqfun(.nPoints_S2,1)),\
                                {{repD2,repD0,repD1}'},\
                                 {repD2,repD0,repD1}');
    AnyRefFrameAxis Normal = y;
    #endif
    
    #if NORMAL == "X"
    //if nPoints_S1 == 1 and nPoints_S2 == 1
    //TRUE: {{0.0,0.0,0.0}}
    //FALSE: {assemble arrays to form position matrix}
    AnyMatrix Positions = iffun(andfun(eqfun(.nPoints_S1,1),eqfun(.nPoints_S2,1)),\
                                {{repD0,repD1,repD2}'},\
                                 {repD0,repD1,repD2}');
    AnyRefFrameAxis Normal = x;
    #endif
  };    
  
  AnyFloat Nodes_sRels = Calculation.Positions;
  AnyFloat Nodes_ARels = Calculation.repARels;
  AnyRefFrameAxis Nodes_Normal = Calculation.Normal;

  CenterFrame = {
            
    AnyRefNodeGroup NAME = {
      NodeAmount = ..nPoints_S1*..nPoints_S2;
      sRel = ..Settings.NodesLinOffset;
      ARel = ..Settings.NodesRotOffset;
      Node_sRels = ..Nodes_sRels;
      Node_ARels = ..Nodes_ARels;
      NodeName = ..Settings.NodesName;
      NodeDefaults.CreateMotionOutput = {
        r = On;
        Axes = On;
      };

    };
      
        
  };
  
};


