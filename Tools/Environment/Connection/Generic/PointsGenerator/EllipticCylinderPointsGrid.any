/* Class Template EllipticCylinderPointsGrid

This class template creates a uniformly distributed grid of 
reference nodes in an elliptical cylinder. One axis of the 
generated nodes is oriented to be normal to the circumference 
of the ellipse while one axis is parallel to the axis of the 
cylinder. The class template requires an AnyRefFrame object 
and grid parameters (defined below). It calculates the relative 
positions and orientations of the reference nodes and uses 
AnyRefNodeGroup to generate the nodes.

Class arguments:
---------------
CENTER_FRAME: <Obligatory>
Is an AnyRefFrame object that is the central frame for the 
elliptical cylinder. This is the reference frame used by 
AnyRefNodeGroup to generate the node group.

AXIS: <Optional. Default = "Z">
Is the axis of the cylinder

NAME: <Optional. Default = NodeGroup>
Name for the instance of the AnyRefNodeGroup class to generate 
the reference nodes.

Obligatory initialization:
-----------------------
Length: <Obligatory>
Is the length of the cylinder. AnyFloat > 0.0

Maj_ax: <Obligatory>
Is the major axis of the ellipse. AnyFloat > 0.0

Min_ax: <Obligatory>
Is the minor axis of the ellipse. AnyFloat > 0.0

nRows: <Obligatory>
Number of rows in the grid. AnyInt > 0

nCols: <Obligatory>
Number of columns in the grid. AnyInt > 0

Optional initialization:
-----------------------
Settings:
    StartAngle	: Angular offset for the first column.
    EndAngle		: Angular offset for the last column.
    NodesName		: Name of the nodes generated by AnyRefNodeGroup. 
                      The nodes are named as NodesName0, NodesName1, 
                      NodesName3, etc.
    NodesLinOffset	: Relative position vector of the node group from 
                      CENTER_FRAME.
    NodesRotOffset	: Relative rotational transformation matrix of the 
                      node group from CENTER_FRAME

Please note:
------------
* EndAngle must be greater than StartAngle.
* If nCOLS is 1, EndAngle - Start Angle must be equal to 2*pi. The 
  single column will be generated at StartAngle
* Uniform distribution on the ellipse requires the assumption 
  that minor axis is less than or equal to the major axis. If 
  minor axis is greater than major axis, the distribution of 
  the nodes may not be uniform.

Initialization example:
----------------------
EllipticCylinderPointsGrid <Object_name> (
      CENTER_FRAME = <AnyRefFrame>,
      AXIS = "<X|Y|*Z>",
      NAME = NodeGroup) = {
        Length = 0.2;
        Maj_ax = 0.12;
        Min_ax = 0.06;
        nRows = 5;
        nCols = 4;
        // Optional initialization showing default values
        Settings = {
          StartAngle = 0*pi;
          EndAngle = 2*pi;
          NodesName = "Node";
          NodesLinOffset = {0,0,0};
          NodesRotOffset = {{1,0,0},{0,1,0},{0,0,1}};
        };
      };

*/


#class_template EllipticCylinderPointsGrid (
CENTER_FRAME,
AXIS = "Z",
NAME = NodeGroup
)
{
  #var AnyFloat Length; // in m
  #var AnyFloat Maj_ax; // in m
  #var AnyFloat Min_ax; // in m (Min_ax <= Maj_ax)
  #var AnyInt nRows;
  #var AnyInt nCols; // if nCols = 1, ensure EndAngle-StartAngle = 2*pi
  AnyRefFrame &CenterFrame = CENTER_FRAME;
  AnyFolder Settings = {
    #var AnyVar StartAngle = 0; // in radians
    #var AnyVar EndAngle = 2*pi; // in radians
    #var AnyStringVar NodesName = "Node"; // 
    #var AnyFloat NodesLinOffset = {0,0,0};
    #var AnyFloat NodesRotOffset = {{1,0,0},{0,1,0},{0,0,1}};
  };
  
  AnyFolder Calculation = {
    AnyInt WARNING_AXES = warn(gteqfun(.Maj_ax,.Min_ax),"Major axis is less than minor axis. Point distribution may not be uniform.");
    
    AnyInt CondCheck = ltfun(.Settings.StartAngle,.Settings.EndAngle);
    AnyInt ERROR_ANGLES = assert(ltfun(.Settings.StartAngle,.Settings.EndAngle),"Please ensure EndAngle is greater than StartAngle") ;

    AnyInt nCOLS_is_1 = expect(iffun(eqfun(.nCols,1),ltfun(abs(.Settings.EndAngle-.Settings.StartAngle-2*pi),1e-5),1),\
                                "When nCols = 1, please ensure EndAngle-StartAngle = 2*pi. The single column will be defined at StartAngle");

    AnyFloat stepH = .Length/.nRows; // step height
    AnyFloat startH = 0.0 - (.Length/2);
    AnyFloat endH = 0.0 + (.Length/2);
    
    // Array for height of each row
    // D2Arr = (if nrows = 1, True: same as parent, False: linspace)
    // linspace returns nan with nrow =1      
    AnyFloat D2Arr = iffun(eqfun(.nRows,1), 0.0,\
                        linspace(startH,endH,.nRows)); // height array
    
    // Array for the rotational angle of each column
    // Avec = (if total angle = 2pi, True: farr, False: linspace)
    // in case full loop is desired, farr needs to be used.
    // With linspace, first and last vertical column will overlap in full loop.
    AnyFloat Avec = iffun(ltfun(abs(.Settings.EndAngle-.Settings.StartAngle-2*pi),1e-5),\
                        farr(.Settings.StartAngle,(.Settings.EndAngle-.Settings.StartAngle)/.nCols, .nCols) + 0*ERROR_ANGLES,\
                        linspace(.Settings.StartAngle,.Settings.EndAngle,.nCols));
    
    /*
    Array for defining t_angle. In case of ellipse, uniformly
    distributed Avec will result in non-equidistant points on 
    the ellipse. t_angle is a function of Avec, maj_ax, and 
    min_ax to generate equidistant points on the ellipse. The
    function requires the assumption that min_ax <= maj_ax. 
    Otherwise, point distribution may not be uniform on the
    ellipse. For more info, see:
    https://math.stackexchange.com/questions/2093569/points-on-an-ellipse
    */    
    AnyFloat esq = 1 - (.Min_ax/.Maj_ax)^2;
    AnyFloat esqT1 = (esq/8 + (esq^2)/16 + (esq^3)*71/2048);
    AnyFloat esqT2 = ((esq^2)*5/256 + (esq^3)*5/256); 
    AnyFloat esqT3 = ((esq^3)*29/6144);
    AnyFloat tvec = Avec + esqT1*sin(2*Avec) + esqT2*sin(4*Avec) + esqT3*sin(6*Avec);
    
    // D0 and D1 coordinates using the t_angle of each column.
    AnyFloat D0Arr = .Maj_ax*cos(tvec); // D0 array
    AnyFloat D1Arr = .Min_ax*sin(tvec); // D1 array
    
    // Normal angles at the points in the ellipse
    AnyFloat Nvec = atan(D1Arr/D0Arr*(.Maj_ax/.Min_ax)^2);
    // Correct for + pi when D0Arr >= 0
    AnyFloat N2vec = iffun(ltfun(D0Arr,0),Nvec,Nvec+pi);
    
    // repeat D0 and D1 coordinates nrow times
    AnyFloat repD0 = repmat(.nRows,D0Arr);
    AnyFloat repD1 = repmat(.nRows,D1Arr);
    // repeat D2 coordinates ncol times and sort
    AnyFloat repD2_unsorted = repmat(.nCols,D2Arr); // repeat height vector ncol times
    AnyFloat repD2 = ObjSort(repD2_unsorted); // sort height vector in ascending order
    
    // repeat angle vector by nrow times for orientation of all points
    AnyFloat RotAngle = repmat(.nRows, N2vec); 
    
    // position coordinates and ARels of nRow*nCol points
    #if AXIS == "Z"
    AnyMatrix Positions = {repD0,repD1,repD2}';
    AnyRefFrameAxis Axis = z;
    AnyFloat ARel_0 = {cos(RotAngle),sin(RotAngle),repmat(SizesOf(RotAngle)[0],{0.0})}';
    AnyFloat ARel_1 = {-sin(RotAngle),cos(RotAngle),repmat(SizesOf(RotAngle)[0],{0.0})}';
    AnyFloat ARel_2 = repmat(SizesOf(RotAngle)[0],{{0,0,1}});
    AnyFloat ARel_Mat = {ARel_0',ARel_1',ARel_2'};
    AnyFloat ARel_transpose = transpose(ARel_Mat);
    #endif
    
    #if AXIS == "Y"
    AnyMatrix Positions = {repD1,repD2,repD0}';
    AnyRefFrameAxis Axis = y;
    AnyFloat ARel_0 = {cos(RotAngle),repmat(SizesOf(RotAngle)[0],{0.0}),-sin(RotAngle)}';
    AnyFloat ARel_1 = repmat(SizesOf(RotAngle)[0],{{0,1,0}});
    AnyFloat ARel_2 = {sin(RotAngle),repmat(SizesOf(RotAngle)[0],{0.0}),cos(RotAngle)}';
    AnyFloat ARel_Mat = {ARel_0',ARel_1',ARel_2'};
    AnyFloat ARel_transpose = transpose(ARel_Mat);
    #endif
    
    #if AXIS == "X"
    AnyMatrix Positions = {repD2,repD0,repD1}';
    AnyRefFrameAxis Axis = x;
    AnyFloat ARel_0 = repmat(SizesOf(RotAngle)[0],{{1,0,0}});
    AnyFloat ARel_1 = {repmat(SizesOf(RotAngle)[0],{0.0}),cos(RotAngle),sin(RotAngle)}';
    AnyFloat ARel_2 = {repmat(SizesOf(RotAngle)[0],{0.0}),-sin(RotAngle),cos(RotAngle)}';
    AnyFloat ARel_Mat = {ARel_0',ARel_1',ARel_2'};
    AnyFloat ARel_transpose = transpose(ARel_Mat);
    #endif
  };    
  
  AnyFloat Nodes_sRels = Calculation.Positions;
  AnyFloat Nodes_ARels = Calculation.ARel_transpose;
  AnyRefFrameAxis Nodes_Axis = Calculation.Axis;

  CenterFrame = {
            
    AnyRefNodeGroup NAME = {
      NodeAmount = ..nRows*..nCols;
      sRel = ..Settings.NodesLinOffset;
      ARel = ..Settings.NodesRotOffset;
      Node_sRels = ..Nodes_sRels;
      Node_ARels = ..Nodes_ARels;
      NodeName = ..Settings.NodesName;
      NodeDefaults.CreateMotionOutput = {
        r = On;
        Axes = On;
      };

    };
      
        
  };
  
};


