//define = (
//   [
//    {'BM_LEG_MODEL':'_LEG_MODEL_TLEM1_'},
//    {'BM_LEG_MODEL':'_LEG_MODEL_TLEM2_'},
//    {'BM_LEG_MODEL':'_LEG_MODEL_LEG_'},
//   ],
//   [
//    {'BM_CALIBRATION_TYPE':'1'},
//    {'BM_CALIBRATION_TYPE':'2'},
//    {'BM_CALIBRATION_TYPE':'3'},
//   ]
//)
//ignore_errors = ['Currently, no room for tendon']
//fatal_warnings = [
//    "Penetration of surface",
//]

#include "libdef.any"

#ifndef TEST_NAME
  #define BM_LEG_MODEL 2
  #define BM_CALIBRATION_TYPE 3
  #define TEST_NAME "test_calibration_lowerbody.any_1"   
#endif


#define BM_SCALING _SCALING_NONE_
#define BM_LEG_TRUNK_INTERFACE _MORPH_TRUNK_TO_LEG_
#define BM_LEG_MUSCLES_RIGHT _MUSCLES_3E_HILL_

#define BM_LEG_LEFT OFF
#define BM_ARM_RIGHT OFF
#define BM_ARM_LEFT OFF


Main = 
{
  
  #include "<ANYBODY_PATH_BODY>/HumanModel.any"  
  
  AnyOperation& RunTest = RunAnalysis;
  AnyOperationSequence RunAnalysis = {

    AnyOperation& Calibration = Main.HumanModel.Calibration.CalibrationSequence;
    
    #if (BM_CALIBRATION_TYPE == 3) & (BM_LEG_MODEL == _LEG_MODEL_TLEM2_)
      AnyOperation& HipFlexExtRoM = Main.HipFlexExtRoM.InverseDynamics;
      AnyOperation& HipAddAbdRoM = Main.HipAddAbdRoM.InverseDynamics;
      AnyOperation& HipRotRoM = Main.HipRotRoM.InverseDynamics;
      AnyOperation& KneeFlexExtRoM = Main.KneeFlexExtRoM.InverseDynamics;
      AnyOperation& AnkleFlexRoM = Main.AnkleFlexRoM.InverseDynamics;
      AnyOperation& AnkleEverInverRoM = Main.AnkleEverInverRoM.InverseDynamics;
    #endif
  };   
  
  /// Template to create a study for the leg - user must provide a driver.
  #class_template RoMTestStudy(__CLASS__ = AnyBodyStudy) {
    Kinematics.SolverType = KinSolOverDeterminate;
    InitialConditions.SolverType = Kinematics.SolverType;
    nStep = 5;
    Gravity = {0, 0, 0};
    InverseDynamics.Criterion.UpperBoundOnOff = Off;
    AnyFolder &Model = Main.HumanModel.BodyModelWithDefaultDrivers;
    
    AnyFixedRefFrame ground = {
      AnyRefNode node = {
        ARel = Main.HumanModel.BodyModel.Trunk.Segments.PelvisSeg.Axes0;
        sRel = Main.HumanModel.BodyModel.Trunk.Segments.PelvisSeg.r0;
      };
    };
    
    AnyKinEq ThoraxFix = {
      AnyKinMeasure& PelvisThoraxExtension = Main.HumanModel.BodyModel.Interface.Trunk.PelvisThoraxExtension;
      AnyKinMeasure& PelvisThoraxLateralBending = Main.HumanModel.BodyModel.Interface.Trunk.PelvisThoraxLateralBending;
      AnyKinMeasure& PelvisThoraxRotation = Main.HumanModel.BodyModel.Interface.Trunk.PelvisThoraxRotation;
    };
    
    AnyKinEq PelvisFix = {
      AnyKinLinear Lin = {
        AnyRefFrame &ground = ..ground.node;
        AnyRefFrame &Pelvis = Main.HumanModel.BodyModel.Trunk.Segments.PelvisSeg;
      };
      AnyKinRotational Rot = {
        Type = RotAxesAngles;
        AnyRefFrame &ground = ..ground.node;
        AnyRefFrame &Pelvis = Main.HumanModel.BodyModel.Trunk.Segments.PelvisSeg;
      };
    };
    
    // tests
    AnyObjectPtrArray muscles_from_cal_studies = flattenptr(ObjSearchRecursive(&Main.HumanModel.Calibration, "MuscleArr"));
    AnyFolder Calculations = {
      AnyObjectPtrArray passive_forces = ObjGetMember(.muscles_from_cal_studies, "Fp");
      AnyFloat passive_forces_vals = Obj2Num(passive_forces);
      AnyObjectPtrArray strengths = ObjGetMember(.muscles_from_cal_studies, "Strength");
      AnyFloat strengths_vals = Obj2Num(strengths);
      AnyObjectPtrArray cal_rmax = ObjSearchRecursive(&Main.HumanModel.Calibration, "RmaxMuscleFiber");
      AnyFloat cal_rmax_vals = Obj2NumFlatten(cal_rmax);
      AnyFloat passive_force_thresholds = mult(strengths_vals, (cal_rmax_vals-1));
      AnyString passive_force_paired_look_up = transpose({CompleteNameOf(.muscles_from_cal_studies), strval(passive_forces_vals), strval(passive_force_thresholds), strval(.test_passive_forces)});
    };
  
    AnyInt test_passive_forces = expect(orfun(
      not(Main.TestTrigger),
      lteqfun(Calculations.passive_forces_vals, Calculations.passive_force_thresholds),
      ),
      "Muscles have to large passive forces!"
    );
    
    InverseDynamics.PreOperation = {
      AnyOperation &EnableTests = Main.SetTestTrigger;
      AnyOperation &UpdateValues = Main.UpdateValues;
    };
    
    InverseDynamics.PostOperation = { AnyOperation &ResetTestTrigger = Main.ResetTestTrigger;};
  };
  
  
  #if (BM_CALIBRATION_TYPE == 3) & (BM_LEG_MODEL == _LEG_MODEL_TLEM2_)
  AnyInt TestTrigger = DesignVar(0);  
  AnyOperationMacro UpdateValues = {
      MacroStr = {"classoperation Main " + strquote("Update Values")};
    };
    AnyOperationSetValue SetTestTrigger = {
      AnyInt dummy = 1;
      Source = {&dummy};
      Target = {&.TestTrigger};
    };
    AnyOperationSetValue ResetTestTrigger = {
      AnyInt dummy = 0;
      Source = {&dummy};
      Target = {&.TestTrigger};
    };

  
  RoMTestStudy HipFlexExtRoM() = {
    AnyKinEqInterPolDriver Hip = {
      AnyKinMeasure &measure = Main.HumanModel.BodyModel.Interface.Right.HipFlexion;
      Type = PiecewiseLinear;
      T = linspace(0,1,.nStep);
      Data = {
        linspace(
        Main.HumanModel.BodyModel.Right.Leg.Data.RangeOfMotion.Hip.MaxExtensionAngle,
        Main.HumanModel.BodyModel.Right.Leg.Data.RangeOfMotion.Hip.MaxFlexionAngle,
        .nStep
        ) * pi/180
      };
      Reaction.Type = {Off};
    };
  };
  RoMTestStudy HipAddAbdRoM() = {    
    AnyKinEqInterPolDriver Hip = {
      AnyKinMeasure &measure = Main.HumanModel.BodyModel.Interface.Right.HipAbduction;
      Type = PiecewiseLinear;
      T = linspace(0,1,.nStep);
      Data = {
        linspace(
        Main.HumanModel.BodyModel.Right.Leg.Data.RangeOfMotion.Hip.MaxAdductionAngle,
        Main.HumanModel.BodyModel.Right.Leg.Data.RangeOfMotion.Hip.MaxAbductionAngle,
        .nStep
        ) * pi/180
      };
      Reaction.Type = {Off};
    };
  };
  RoMTestStudy HipRotRoM() = {    
    AnyKinEqInterPolDriver Hip = {
      AnyKinMeasure &measure = Main.HumanModel.BodyModel.Interface.Right.HipExternalRotation;
      Type = PiecewiseLinear;
      T = linspace(0,1,.nStep);
      Data = {
        linspace(
        Main.HumanModel.BodyModel.Right.Leg.Data.RangeOfMotion.Hip.MaxExternalRotationAngle,
        Main.HumanModel.BodyModel.Right.Leg.Data.RangeOfMotion.Hip.MaxInternalRotationAngle,
        .nStep
        ) * pi/180
      };
      Reaction.Type = {Off};
    };
  };
  RoMTestStudy KneeFlexExtRoM() = {    
    AnyKinEqInterPolDriver Knee = {
      AnyKinMeasure &measure = Main.HumanModel.BodyModel.Interface.Right.KneeFlexion;
      Type = PiecewiseLinear;
      T = linspace(0,1,.nStep);
      Data = {
        linspace(
        Main.HumanModel.BodyModel.Right.Leg.Data.RangeOfMotion.Knee.MaxExtensionAngle,
        Main.HumanModel.BodyModel.Right.Leg.Data.RangeOfMotion.Knee.MaxFlexionAngle,
        .nStep
        ) * pi/180
      };
      Reaction.Type = {Off};
    };
  };
  RoMTestStudy AnkleFlexRoM() = {    
    AnyKinEqInterPolDriver Ankle = {
      AnyKinMeasure &measure = Main.HumanModel.BodyModel.Interface.Right.AnklePlantarFlexion;
      Type = PiecewiseLinear;
      T = linspace(0,1,.nStep);
      Data = {
        linspace(
        Main.HumanModel.BodyModel.Right.Leg.Data.RangeOfMotion.Ankle.MaxPlantarFlexionAngle,
        Main.HumanModel.BodyModel.Right.Leg.Data.RangeOfMotion.Ankle.MaxDorsiFlexionAngle,
        .nStep
        ) * pi/180
      };
      Reaction.Type = {Off};
    };
  };
  RoMTestStudy AnkleEverInverRoM() = {    
    AnyKinEqInterPolDriver Ankle = {
      AnyKinMeasure &measure = Main.HumanModel.BodyModel.Interface.Right.SubTalarEversion;
      Type = PiecewiseLinear;
      T = linspace(0,1,.nStep);
      Data = {
        linspace(
        Main.HumanModel.BodyModel.Right.Leg.Data.RangeOfMotion.Ankle.MaxEversionAngle,
        Main.HumanModel.BodyModel.Right.Leg.Data.RangeOfMotion.Ankle.MaxInversionAngle,
        .nStep
        ) * pi/180
      };
      Reaction.Type = {Off};
    };
  };
  #endif
};

